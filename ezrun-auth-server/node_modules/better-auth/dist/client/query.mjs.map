{"version":3,"file":"query.mjs","names":["value: AuthQueryAtom<T>"],"sources":["../../src/client/query.ts"],"sourcesContent":["import type { ClientFetchOption } from \"@better-auth/core\";\nimport type { BetterFetch, BetterFetchError } from \"@better-fetch/fetch\";\nimport type { PreinitializedWritableAtom } from \"nanostores\";\nimport { atom, onMount } from \"nanostores\";\nimport type { SessionQueryParams } from \"./types\";\n\n// SSR detection\nconst isServer = () => typeof window === \"undefined\";\n\nexport type AuthQueryAtom<T> = PreinitializedWritableAtom<{\n\tdata: null | T;\n\terror: null | BetterFetchError;\n\tisPending: boolean;\n\tisRefetching: boolean;\n\trefetch: (\n\t\tqueryParams?: { query?: SessionQueryParams } | undefined,\n\t) => Promise<void>;\n}>;\n\nexport const useAuthQuery = <T>(\n\tinitializedAtom:\n\t\t| PreinitializedWritableAtom<any>\n\t\t| PreinitializedWritableAtom<any>[],\n\tpath: string,\n\t$fetch: BetterFetch,\n\toptions?:\n\t\t| (\n\t\t\t\t| ((value: {\n\t\t\t\t\t\tdata: null | T;\n\t\t\t\t\t\terror: null | BetterFetchError;\n\t\t\t\t\t\tisPending: boolean;\n\t\t\t\t  }) => ClientFetchOption)\n\t\t\t\t| ClientFetchOption\n\t\t  )\n\t\t| undefined,\n) => {\n\tconst value: AuthQueryAtom<T> = atom({\n\t\tdata: null,\n\t\terror: null,\n\t\tisPending: true,\n\t\tisRefetching: false,\n\t\trefetch: (queryParams) => fn(queryParams),\n\t});\n\n\tconst fn = async (\n\t\tqueryParams?: { query?: SessionQueryParams } | undefined,\n\t) => {\n\t\treturn new Promise<void>((resolve) => {\n\t\t\tconst opts =\n\t\t\t\ttypeof options === \"function\"\n\t\t\t\t\t? options({\n\t\t\t\t\t\t\tdata: value.get().data,\n\t\t\t\t\t\t\terror: value.get().error,\n\t\t\t\t\t\t\tisPending: value.get().isPending,\n\t\t\t\t\t\t})\n\t\t\t\t\t: options;\n\n\t\t\t$fetch<T>(path, {\n\t\t\t\t...opts,\n\t\t\t\tquery: {\n\t\t\t\t\t...opts?.query,\n\t\t\t\t\t...queryParams?.query,\n\t\t\t\t},\n\t\t\t\tasync onSuccess(context) {\n\t\t\t\t\tvalue.set({\n\t\t\t\t\t\tdata: context.data,\n\t\t\t\t\t\terror: null,\n\t\t\t\t\t\tisPending: false,\n\t\t\t\t\t\tisRefetching: false,\n\t\t\t\t\t\trefetch: value.value.refetch,\n\t\t\t\t\t});\n\t\t\t\t\tawait opts?.onSuccess?.(context);\n\t\t\t\t},\n\t\t\t\tasync onError(context) {\n\t\t\t\t\tconst { request } = context;\n\t\t\t\t\tconst retryAttempts =\n\t\t\t\t\t\ttypeof request.retry === \"number\"\n\t\t\t\t\t\t\t? request.retry\n\t\t\t\t\t\t\t: request.retry?.attempts;\n\t\t\t\t\tconst retryAttempt = request.retryAttempt || 0;\n\t\t\t\t\tif (retryAttempts && retryAttempt < retryAttempts) return;\n\t\t\t\t\tvalue.set({\n\t\t\t\t\t\terror: context.error,\n\t\t\t\t\t\tdata: null,\n\t\t\t\t\t\tisPending: false,\n\t\t\t\t\t\tisRefetching: false,\n\t\t\t\t\t\trefetch: value.value.refetch,\n\t\t\t\t\t});\n\t\t\t\t\tawait opts?.onError?.(context);\n\t\t\t\t},\n\t\t\t\tasync onRequest(context) {\n\t\t\t\t\tconst currentValue = value.get();\n\t\t\t\t\tvalue.set({\n\t\t\t\t\t\tisPending: currentValue.data === null,\n\t\t\t\t\t\tdata: currentValue.data,\n\t\t\t\t\t\terror: null,\n\t\t\t\t\t\tisRefetching: true,\n\t\t\t\t\t\trefetch: value.value.refetch,\n\t\t\t\t\t});\n\t\t\t\t\tawait opts?.onRequest?.(context);\n\t\t\t\t},\n\t\t\t})\n\t\t\t\t.catch((error) => {\n\t\t\t\t\tvalue.set({\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tdata: null,\n\t\t\t\t\t\tisPending: false,\n\t\t\t\t\t\tisRefetching: false,\n\t\t\t\t\t\trefetch: value.value.refetch,\n\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t.finally(() => {\n\t\t\t\t\tresolve(void 0);\n\t\t\t\t});\n\t\t});\n\t};\n\tinitializedAtom = Array.isArray(initializedAtom)\n\t\t? initializedAtom\n\t\t: [initializedAtom];\n\tlet isMounted = false;\n\n\tfor (const initAtom of initializedAtom) {\n\t\tinitAtom.subscribe(async () => {\n\t\t\tif (isServer()) {\n\t\t\t\t// On server, don't trigger fetch\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isMounted) {\n\t\t\t\tawait fn();\n\t\t\t} else {\n\t\t\t\tonMount(value, () => {\n\t\t\t\t\tconst timeoutId = setTimeout(async () => {\n\t\t\t\t\t\tif (!isMounted) {\n\t\t\t\t\t\t\tawait fn();\n\t\t\t\t\t\t\tisMounted = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 0);\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tvalue.off();\n\t\t\t\t\t\tinitAtom.off();\n\t\t\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\treturn value;\n};\n"],"mappings":";;;AAOA,MAAM,iBAAiB,OAAO,WAAW;AAYzC,MAAa,gBACZ,iBAGA,MACA,QACA,YAUI;CACJ,MAAMA,QAA0B,KAAK;EACpC,MAAM;EACN,OAAO;EACP,WAAW;EACX,cAAc;EACd,UAAU,gBAAgB,GAAG,YAAY;EACzC,CAAC;CAEF,MAAM,KAAK,OACV,gBACI;AACJ,SAAO,IAAI,SAAe,YAAY;GACrC,MAAM,OACL,OAAO,YAAY,aAChB,QAAQ;IACR,MAAM,MAAM,KAAK,CAAC;IAClB,OAAO,MAAM,KAAK,CAAC;IACnB,WAAW,MAAM,KAAK,CAAC;IACvB,CAAC,GACD;AAEJ,UAAU,MAAM;IACf,GAAG;IACH,OAAO;KACN,GAAG,MAAM;KACT,GAAG,aAAa;KAChB;IACD,MAAM,UAAU,SAAS;AACxB,WAAM,IAAI;MACT,MAAM,QAAQ;MACd,OAAO;MACP,WAAW;MACX,cAAc;MACd,SAAS,MAAM,MAAM;MACrB,CAAC;AACF,WAAM,MAAM,YAAY,QAAQ;;IAEjC,MAAM,QAAQ,SAAS;KACtB,MAAM,EAAE,YAAY;KACpB,MAAM,gBACL,OAAO,QAAQ,UAAU,WACtB,QAAQ,QACR,QAAQ,OAAO;KACnB,MAAM,eAAe,QAAQ,gBAAgB;AAC7C,SAAI,iBAAiB,eAAe,cAAe;AACnD,WAAM,IAAI;MACT,OAAO,QAAQ;MACf,MAAM;MACN,WAAW;MACX,cAAc;MACd,SAAS,MAAM,MAAM;MACrB,CAAC;AACF,WAAM,MAAM,UAAU,QAAQ;;IAE/B,MAAM,UAAU,SAAS;KACxB,MAAM,eAAe,MAAM,KAAK;AAChC,WAAM,IAAI;MACT,WAAW,aAAa,SAAS;MACjC,MAAM,aAAa;MACnB,OAAO;MACP,cAAc;MACd,SAAS,MAAM,MAAM;MACrB,CAAC;AACF,WAAM,MAAM,YAAY,QAAQ;;IAEjC,CAAC,CACA,OAAO,UAAU;AACjB,UAAM,IAAI;KACT;KACA,MAAM;KACN,WAAW;KACX,cAAc;KACd,SAAS,MAAM,MAAM;KACrB,CAAC;KACD,CACD,cAAc;AACd,YAAQ,KAAK,EAAE;KACd;IACF;;AAEH,mBAAkB,MAAM,QAAQ,gBAAgB,GAC7C,kBACA,CAAC,gBAAgB;CACpB,IAAI,YAAY;AAEhB,MAAK,MAAM,YAAY,gBACtB,UAAS,UAAU,YAAY;AAC9B,MAAI,UAAU,CAEb;AAED,MAAI,UACH,OAAM,IAAI;MAEV,SAAQ,aAAa;GACpB,MAAM,YAAY,WAAW,YAAY;AACxC,QAAI,CAAC,WAAW;AACf,WAAM,IAAI;AACV,iBAAY;;MAEX,EAAE;AACL,gBAAa;AACZ,UAAM,KAAK;AACX,aAAS,KAAK;AACd,iBAAa,UAAU;;IAEvB;GAEF;AAEH,QAAO"}