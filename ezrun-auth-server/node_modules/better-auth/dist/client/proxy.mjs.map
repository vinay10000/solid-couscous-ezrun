{"version":3,"file":"proxy.mjs","names":["current: any"],"sources":["../../src/client/proxy.ts"],"sourcesContent":["import type {\n\tBetterAuthClientPlugin,\n\tClientAtomListener,\n\tClientFetchOption,\n} from \"@better-auth/core\";\nimport type { BetterFetch } from \"@better-fetch/fetch\";\nimport type { Atom } from \"nanostores\";\nimport { isAtom } from \"../utils/is-atom\";\nimport type { ProxyRequest } from \"./path-to-object\";\n\nfunction getMethod(\n\tpath: string,\n\tknownPathMethods: Record<string, \"POST\" | \"GET\">,\n\targs:\n\t\t| {\n\t\t\t\tfetchOptions?: ClientFetchOption | undefined;\n\t\t\t\tquery?: Record<string, any> | undefined;\n\t\t  }\n\t\t| undefined,\n) {\n\tconst method = knownPathMethods[path];\n\tconst { fetchOptions, query: _query, ...body } = args || {};\n\tif (method) {\n\t\treturn method;\n\t}\n\tif (fetchOptions?.method) {\n\t\treturn fetchOptions.method;\n\t}\n\tif (body && Object.keys(body).length > 0) {\n\t\treturn \"POST\";\n\t}\n\treturn \"GET\";\n}\n\nexport function createDynamicPathProxy<T extends Record<string, any>>(\n\troutes: T,\n\tclient: BetterFetch,\n\tknownPathMethods: Record<string, \"POST\" | \"GET\">,\n\tatoms: Record<string, Atom>,\n\tatomListeners: BetterAuthClientPlugin[\"atomListeners\"],\n): T {\n\tfunction createProxy(path: string[] = []): any {\n\t\treturn new Proxy(function () {}, {\n\t\t\tget(_, prop) {\n\t\t\t\tif (typeof prop !== \"string\") {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (prop === \"then\" || prop === \"catch\" || prop === \"finally\") {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tconst fullPath = [...path, prop];\n\t\t\t\tlet current: any = routes;\n\t\t\t\tfor (const segment of fullPath) {\n\t\t\t\t\tif (current && typeof current === \"object\" && segment in current) {\n\t\t\t\t\t\tcurrent = current[segment];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent = undefined;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (typeof current === \"function\") {\n\t\t\t\t\treturn current;\n\t\t\t\t}\n\t\t\t\tif (isAtom(current)) {\n\t\t\t\t\treturn current;\n\t\t\t\t}\n\t\t\t\treturn createProxy(fullPath);\n\t\t\t},\n\t\t\tapply: async (_, __, args) => {\n\t\t\t\tconst routePath =\n\t\t\t\t\t\"/\" +\n\t\t\t\t\tpath\n\t\t\t\t\t\t.map((segment) =>\n\t\t\t\t\t\t\tsegment.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`),\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.join(\"/\");\n\t\t\t\tconst arg = (args[0] || {}) as ProxyRequest;\n\t\t\t\tconst fetchOptions = (args[1] || {}) as ClientFetchOption;\n\t\t\t\tconst { query, fetchOptions: argFetchOptions, ...body } = arg;\n\t\t\t\tconst options = {\n\t\t\t\t\t...fetchOptions,\n\t\t\t\t\t...argFetchOptions,\n\t\t\t\t} as ClientFetchOption;\n\t\t\t\tconst method = getMethod(routePath, knownPathMethods, arg);\n\t\t\t\treturn await client(routePath, {\n\t\t\t\t\t...options,\n\t\t\t\t\tbody:\n\t\t\t\t\t\tmethod === \"GET\"\n\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t...body,\n\t\t\t\t\t\t\t\t\t...(options?.body || {}),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\tquery: query || options?.query,\n\t\t\t\t\tmethod,\n\t\t\t\t\tasync onSuccess(context) {\n\t\t\t\t\t\tawait options?.onSuccess?.(context);\n\t\t\t\t\t\tif (!atomListeners || options.disableSignal) return;\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * We trigger listeners\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst matches = atomListeners.filter((s) => s.matcher(routePath));\n\t\t\t\t\t\tif (!matches.length) return;\n\n\t\t\t\t\t\tconst visited = new Set<ClientAtomListener[\"signal\"]>();\n\t\t\t\t\t\tfor (const match of matches) {\n\t\t\t\t\t\t\tconst signal = atoms[match.signal as any];\n\t\t\t\t\t\t\tif (!signal) return;\n\t\t\t\t\t\t\tif (visited.has(match.signal)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvisited.add(match.signal);\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * To avoid race conditions we set the signal in a setTimeout\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst val = signal.get();\n\t\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\t\t\t\tsignal.set(!val);\n\t\t\t\t\t\t\t}, 10);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t},\n\t\t});\n\t}\n\treturn createProxy() as T;\n}\n"],"mappings":";;;AAUA,SAAS,UACR,MACA,kBACA,MAMC;CACD,MAAM,SAAS,iBAAiB;CAChC,MAAM,EAAE,cAAc,OAAO,QAAQ,GAAG,SAAS,QAAQ,EAAE;AAC3D,KAAI,OACH,QAAO;AAER,KAAI,cAAc,OACjB,QAAO,aAAa;AAErB,KAAI,QAAQ,OAAO,KAAK,KAAK,CAAC,SAAS,EACtC,QAAO;AAER,QAAO;;AAGR,SAAgB,uBACf,QACA,QACA,kBACA,OACA,eACI;CACJ,SAAS,YAAY,OAAiB,EAAE,EAAO;AAC9C,SAAO,IAAI,MAAM,WAAY,IAAI;GAChC,IAAI,GAAG,MAAM;AACZ,QAAI,OAAO,SAAS,SACnB;AAED,QAAI,SAAS,UAAU,SAAS,WAAW,SAAS,UACnD;IAED,MAAM,WAAW,CAAC,GAAG,MAAM,KAAK;IAChC,IAAIA,UAAe;AACnB,SAAK,MAAM,WAAW,SACrB,KAAI,WAAW,OAAO,YAAY,YAAY,WAAW,QACxD,WAAU,QAAQ;SACZ;AACN,eAAU;AACV;;AAGF,QAAI,OAAO,YAAY,WACtB,QAAO;AAER,QAAI,OAAO,QAAQ,CAClB,QAAO;AAER,WAAO,YAAY,SAAS;;GAE7B,OAAO,OAAO,GAAG,IAAI,SAAS;IAC7B,MAAM,YACL,MACA,KACE,KAAK,YACL,QAAQ,QAAQ,WAAW,WAAW,IAAI,OAAO,aAAa,GAAG,CACjE,CACA,KAAK,IAAI;IACZ,MAAM,MAAO,KAAK,MAAM,EAAE;IAC1B,MAAM,eAAgB,KAAK,MAAM,EAAE;IACnC,MAAM,EAAE,OAAO,cAAc,iBAAiB,GAAG,SAAS;IAC1D,MAAM,UAAU;KACf,GAAG;KACH,GAAG;KACH;IACD,MAAM,SAAS,UAAU,WAAW,kBAAkB,IAAI;AAC1D,WAAO,MAAM,OAAO,WAAW;KAC9B,GAAG;KACH,MACC,WAAW,QACR,SACA;MACA,GAAG;MACH,GAAI,SAAS,QAAQ,EAAE;MACvB;KACJ,OAAO,SAAS,SAAS;KACzB;KACA,MAAM,UAAU,SAAS;AACxB,YAAM,SAAS,YAAY,QAAQ;AACnC,UAAI,CAAC,iBAAiB,QAAQ,cAAe;;;;MAI7C,MAAM,UAAU,cAAc,QAAQ,MAAM,EAAE,QAAQ,UAAU,CAAC;AACjE,UAAI,CAAC,QAAQ,OAAQ;MAErB,MAAM,0BAAU,IAAI,KAAmC;AACvD,WAAK,MAAM,SAAS,SAAS;OAC5B,MAAM,SAAS,MAAM,MAAM;AAC3B,WAAI,CAAC,OAAQ;AACb,WAAI,QAAQ,IAAI,MAAM,OAAO,CAC5B;AAED,eAAQ,IAAI,MAAM,OAAO;;;;OAIzB,MAAM,MAAM,OAAO,KAAK;AACxB,wBAAiB;AAEhB,eAAO,IAAI,CAAC,IAAI;UACd,GAAG;;;KAGR,CAAC;;GAEH,CAAC;;AAEH,QAAO,aAAa"}