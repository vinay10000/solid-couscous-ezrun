{"version":3,"file":"index.mjs","names":["resolvedHooks: Record<string, any>"],"sources":["../../../src/client/vue/index.ts"],"sourcesContent":["import type {\n\tBetterAuthClientOptions,\n\tBetterAuthClientPlugin,\n} from \"@better-auth/core\";\nimport type { BASE_ERROR_CODES } from \"@better-auth/core/error\";\nimport { capitalizeFirstLetter } from \"@better-auth/core/utils\";\nimport type {\n\tBetterFetchError,\n\tBetterFetchResponse,\n} from \"@better-fetch/fetch\";\nimport type { DeepReadonly, Ref } from \"vue\";\nimport type { PrettifyDeep, UnionToIntersection } from \"../../types/helper\";\nimport { getClientConfig } from \"../config\";\nimport { createDynamicPathProxy } from \"../proxy\";\nimport type {\n\tInferActions,\n\tInferClientAPI,\n\tInferErrorCodes,\n\tIsSignal,\n\tSessionQueryParams,\n} from \"../types\";\nimport { useStore } from \"./vue-store\";\n\nfunction getAtomKey(str: string) {\n\treturn `use${capitalizeFirstLetter(str)}`;\n}\n\ntype InferResolvedHooks<O extends BetterAuthClientOptions> = O extends {\n\tplugins: Array<infer Plugin>;\n}\n\t? UnionToIntersection<\n\t\t\tPlugin extends BetterAuthClientPlugin\n\t\t\t\t? Plugin[\"getAtoms\"] extends (fetch: any) => infer Atoms\n\t\t\t\t\t? Atoms extends Record<string, any>\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t[key in keyof Atoms as IsSignal<key> extends true\n\t\t\t\t\t\t\t\t\t? never\n\t\t\t\t\t\t\t\t\t: key extends string\n\t\t\t\t\t\t\t\t\t\t? `use${Capitalize<key>}`\n\t\t\t\t\t\t\t\t\t\t: never]: () => DeepReadonly<\n\t\t\t\t\t\t\t\t\tRef<ReturnType<Atoms[key][\"get\"]>>\n\t\t\t\t\t\t\t\t>;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {}\n\t\t\t\t\t: {}\n\t\t\t\t: {}\n\t\t>\n\t: {};\n\nexport function createAuthClient<Option extends BetterAuthClientOptions>(\n\toptions?: Option | undefined,\n) {\n\tconst {\n\t\tbaseURL,\n\t\tpluginPathMethods,\n\t\tpluginsActions,\n\t\tpluginsAtoms,\n\t\t$fetch,\n\t\t$store,\n\t\tatomListeners,\n\t} = getClientConfig(options, false);\n\tconst resolvedHooks: Record<string, any> = {};\n\tfor (const [key, value] of Object.entries(pluginsAtoms)) {\n\t\tresolvedHooks[getAtomKey(key)] = () => useStore(value);\n\t}\n\n\ttype ClientAPI = InferClientAPI<Option>;\n\ttype Session = ClientAPI extends {\n\t\tgetSession: () => Promise<infer Res>;\n\t}\n\t\t? Res extends BetterFetchResponse<infer S>\n\t\t\t? S\n\t\t\t: Res extends Record<string, any>\n\t\t\t\t? Res\n\t\t\t\t: never\n\t\t: never;\n\n\tfunction useSession(): DeepReadonly<\n\t\tRef<{\n\t\t\tdata: Session;\n\t\t\tisPending: boolean;\n\t\t\tisRefetching: boolean;\n\t\t\terror: BetterFetchError | null;\n\t\t\trefetch: (\n\t\t\t\tqueryParams?: { query?: SessionQueryParams } | undefined,\n\t\t\t) => Promise<void>;\n\t\t}>\n\t>;\n\tfunction useSession<F extends (...args: any) => any>(\n\t\tuseFetch: F,\n\t): Promise<{\n\t\tdata: Ref<Session>;\n\t\tisPending: false; //this is just to be consistent with the default hook\n\t\terror: Ref<{\n\t\t\tmessage?: string | undefined;\n\t\t\tstatus: number;\n\t\t\tstatusText: string;\n\t\t}>;\n\t}>;\n\tfunction useSession<UseFetch extends <_T>(...args: any) => any>(\n\t\tuseFetch?: UseFetch | undefined,\n\t) {\n\t\tif (useFetch) {\n\t\t\tconst ref = useStore(pluginsAtoms.$sessionSignal!);\n\t\t\treturn useFetch(`${baseURL}/get-session`, {\n\t\t\t\tref,\n\t\t\t}).then((res: any) => {\n\t\t\t\treturn {\n\t\t\t\t\tdata: res.data,\n\t\t\t\t\tisPending: false,\n\t\t\t\t\terror: res.error,\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\treturn resolvedHooks.useSession();\n\t}\n\n\tconst routes = {\n\t\t...pluginsActions,\n\t\t...resolvedHooks,\n\t\tuseSession,\n\t\t$fetch,\n\t\t$store,\n\t};\n\n\tconst proxy = createDynamicPathProxy(\n\t\troutes,\n\t\t$fetch,\n\t\tpluginPathMethods,\n\t\tpluginsAtoms,\n\t\tatomListeners,\n\t);\n\n\treturn proxy as UnionToIntersection<InferResolvedHooks<Option>> &\n\t\tInferClientAPI<Option> &\n\t\tInferActions<Option> & {\n\t\t\tuseSession: typeof useSession;\n\t\t\t$Infer: {\n\t\t\t\tSession: NonNullable<Session>;\n\t\t\t};\n\t\t\t$fetch: typeof $fetch;\n\t\t\t$store: typeof $store;\n\t\t\t$ERROR_CODES: PrettifyDeep<\n\t\t\t\tInferErrorCodes<Option> & typeof BASE_ERROR_CODES\n\t\t\t>;\n\t\t};\n}\n\nexport type * from \"@better-fetch/fetch\";\nexport type * from \"nanostores\";\nexport type * from \"../../types/helper\";\nexport type { UnionToIntersection } from \"../../types/helper\";\n"],"mappings":";;;;;;AAuBA,SAAS,WAAW,KAAa;AAChC,QAAO,MAAM,sBAAsB,IAAI;;AAyBxC,SAAgB,iBACf,SACC;CACD,MAAM,EACL,SACA,mBACA,gBACA,cACA,QACA,QACA,kBACG,gBAAgB,SAAS,MAAM;CACnC,MAAMA,gBAAqC,EAAE;AAC7C,MAAK,MAAM,CAAC,KAAK,UAAU,OAAO,QAAQ,aAAa,CACtD,eAAc,WAAW,IAAI,UAAU,SAAS,MAAM;CAoCvD,SAAS,WACR,UACC;AACD,MAAI,UAAU;GACb,MAAM,MAAM,SAAS,aAAa,eAAgB;AAClD,UAAO,SAAS,GAAG,QAAQ,eAAe,EACzC,KACA,CAAC,CAAC,MAAM,QAAa;AACrB,WAAO;KACN,MAAM,IAAI;KACV,WAAW;KACX,OAAO,IAAI;KACX;KACA;;AAEH,SAAO,cAAc,YAAY;;AAmBlC,QARc,uBARC;EACd,GAAG;EACH,GAAG;EACH;EACA;EACA;EACA,EAIA,QACA,mBACA,cACA,cACA"}