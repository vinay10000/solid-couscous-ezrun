{"version":3,"file":"internal-adapter.mjs","names":["list: { token: string; expiresAt: number }[]","sessions: Session[]","ctx","data: Omit<Session, \"id\">","sessions: {\n\t\t\t\t\tsession: Session;\n\t\t\t\t\tuser: User;\n\t\t\t\t}[]","sessions","session","options"],"sources":["../../src/db/internal-adapter.ts"],"sourcesContent":["import type {\n\tAuthContext,\n\tBetterAuthOptions,\n\tInternalAdapter,\n} from \"@better-auth/core\";\nimport {\n\tgetCurrentAdapter,\n\tgetCurrentAuthContext,\n\trunWithTransaction,\n} from \"@better-auth/core/context\";\nimport type { DBAdapter, Where } from \"@better-auth/core/db/adapter\";\nimport type { InternalLogger } from \"@better-auth/core/env\";\nimport { generateId, safeJSONParse } from \"@better-auth/core/utils\";\nimport type { Account, Session, User, Verification } from \"../types\";\nimport { getDate } from \"../utils/date\";\nimport { getIp } from \"../utils/get-request-ip\";\nimport {\n\tparseSessionInput,\n\tparseSessionOutput,\n\tparseUserOutput,\n} from \"./schema\";\nimport { getWithHooks } from \"./with-hooks\";\n\nexport const createInternalAdapter = (\n\tadapter: DBAdapter<BetterAuthOptions>,\n\tctx: {\n\t\toptions: Omit<BetterAuthOptions, \"logger\">;\n\t\tlogger: InternalLogger;\n\t\thooks: Exclude<BetterAuthOptions[\"databaseHooks\"], undefined>[];\n\t\tgenerateId: AuthContext[\"generateId\"];\n\t},\n): InternalAdapter => {\n\tconst logger = ctx.logger;\n\tconst options = ctx.options;\n\tconst secondaryStorage = options.secondaryStorage;\n\tconst sessionExpiration = options.session?.expiresIn || 60 * 60 * 24 * 7; // 7 days\n\tconst {\n\t\tcreateWithHooks,\n\t\tupdateWithHooks,\n\t\tupdateManyWithHooks,\n\t\tdeleteWithHooks,\n\t\tdeleteManyWithHooks,\n\t} = getWithHooks(adapter, ctx);\n\n\tasync function refreshUserSessions(user: User) {\n\t\tif (!secondaryStorage) return;\n\n\t\tconst listRaw = await secondaryStorage.get(`active-sessions-${user.id}`);\n\t\tif (!listRaw) return;\n\n\t\tconst now = Date.now();\n\t\tconst list =\n\t\t\tsafeJSONParse<{ token: string; expiresAt: number }[]>(listRaw) || [];\n\t\tconst validSessions = list.filter((s) => s.expiresAt > now);\n\n\t\tawait Promise.all(\n\t\t\tvalidSessions.map(async ({ token }) => {\n\t\t\t\tconst cached = await secondaryStorage.get(token);\n\t\t\t\tif (!cached) return;\n\t\t\t\tconst parsed = safeJSONParse<{ session: Session; user: User }>(cached);\n\t\t\t\tif (!parsed) return;\n\n\t\t\t\tconst sessionTTL = Math.max(\n\t\t\t\t\tMath.floor(new Date(parsed.session.expiresAt).getTime() - now) / 1000,\n\t\t\t\t\t0,\n\t\t\t\t);\n\n\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\ttoken,\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\tsession: parsed.session,\n\t\t\t\t\t\tuser,\n\t\t\t\t\t}),\n\t\t\t\t\tMath.floor(sessionTTL),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t}\n\n\treturn {\n\t\tcreateOAuthUser: async (\n\t\t\tuser: Omit<User, \"id\" | \"createdAt\" | \"updatedAt\">,\n\t\t\taccount: Omit<Account, \"userId\" | \"id\" | \"createdAt\" | \"updatedAt\"> &\n\t\t\t\tPartial<Account>,\n\t\t) => {\n\t\t\treturn runWithTransaction(adapter, async () => {\n\t\t\t\tconst createdUser = await createWithHooks(\n\t\t\t\t\t{\n\t\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t\t...user,\n\t\t\t\t\t},\n\t\t\t\t\t\"user\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t\tconst createdAccount = await createWithHooks(\n\t\t\t\t\t{\n\t\t\t\t\t\t...account,\n\t\t\t\t\t\tuserId: createdUser!.id,\n\t\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t},\n\t\t\t\t\t\"account\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t\treturn {\n\t\t\t\t\tuser: createdUser,\n\t\t\t\t\taccount: createdAccount,\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\t\tcreateUser: async <T>(\n\t\t\tuser: Omit<User, \"id\" | \"createdAt\" | \"updatedAt\" | \"emailVerified\"> &\n\t\t\t\tPartial<User> &\n\t\t\t\tRecord<string, any>,\n\t\t) => {\n\t\t\tconst createdUser = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...user,\n\t\t\t\t\temail: user.email?.toLowerCase(),\n\t\t\t\t},\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\n\t\t\treturn createdUser as T & User;\n\t\t},\n\t\tcreateAccount: async <T extends Record<string, any>>(\n\t\t\taccount: Omit<Account, \"id\" | \"createdAt\" | \"updatedAt\"> &\n\t\t\t\tPartial<Account> &\n\t\t\t\tT,\n\t\t) => {\n\t\t\tconst createdAccount = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...account,\n\t\t\t\t},\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn createdAccount as T & Account;\n\t\t},\n\t\tlistSessions: async (userId: string) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst currentList = await secondaryStorage.get(\n\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t);\n\t\t\t\tif (!currentList) return [];\n\n\t\t\t\tconst list: { token: string; expiresAt: number }[] =\n\t\t\t\t\tsafeJSONParse(currentList) || [];\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\tconst seenTokens = new Set<string>();\n\t\t\t\tconst sessions: Session[] = [];\n\n\t\t\t\tfor (const { token, expiresAt } of list) {\n\t\t\t\t\tif (expiresAt <= now || seenTokens.has(token)) continue;\n\t\t\t\t\tseenTokens.add(token);\n\n\t\t\t\t\tconst data = await secondaryStorage.get(token);\n\t\t\t\t\tif (!data) continue;\n\n\t\t\t\t\tconst parsed = safeJSONParse<{\n\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\tuser: User;\n\t\t\t\t\t}>(data);\n\t\t\t\t\tif (!parsed) continue;\n\n\t\t\t\t\tsessions.push(\n\t\t\t\t\t\tparseSessionOutput(ctx.options, {\n\t\t\t\t\t\t\t...parsed.session,\n\t\t\t\t\t\t\texpiresAt: new Date(parsed.session.expiresAt),\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn sessions;\n\t\t\t}\n\n\t\t\tconst sessions = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Session>({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn sessions;\n\t\t},\n\t\tlistUsers: async (\n\t\t\tlimit?: number | undefined,\n\t\t\toffset?: number | undefined,\n\t\t\tsortBy?:\n\t\t\t\t| {\n\t\t\t\t\t\tfield: string;\n\t\t\t\t\t\tdirection: \"asc\" | \"desc\";\n\t\t\t\t  }\n\t\t\t\t| undefined,\n\t\t\twhere?: Where[] | undefined,\n\t\t) => {\n\t\t\tconst users = await (await getCurrentAdapter(adapter)).findMany<User>({\n\t\t\t\tmodel: \"user\",\n\t\t\t\tlimit,\n\t\t\t\toffset,\n\t\t\t\tsortBy,\n\t\t\t\twhere,\n\t\t\t});\n\t\t\treturn users;\n\t\t},\n\t\tcountTotalUsers: async (where?: Where[] | undefined) => {\n\t\t\tconst total = await (await getCurrentAdapter(adapter)).count({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere,\n\t\t\t});\n\t\t\tif (typeof total === \"string\") {\n\t\t\t\treturn parseInt(total);\n\t\t\t}\n\t\t\treturn total;\n\t\t},\n\t\tdeleteUser: async (userId: string) => {\n\t\t\tif (!secondaryStorage || options.session?.storeSessionInDatabase) {\n\t\t\t\tawait deleteManyWithHooks(\n\t\t\t\t\t[\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\t\"session\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t}\n\t\t\tawait deleteManyWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tcreateSession: async (\n\t\t\tuserId: string,\n\t\t\tdontRememberMe?: boolean | undefined,\n\t\t\toverride?: (Partial<Session> & Record<string, any>) | undefined,\n\t\t\toverrideAll?: boolean | undefined,\n\t\t) => {\n\t\t\tconst ctx = await getCurrentAuthContext().catch(() => null);\n\t\t\tconst headers = ctx?.headers || ctx?.request?.headers;\n\t\t\tconst { id: _, ...rest } = override || {};\n\t\t\t//we're parsing default values for session additional fields\n\t\t\tconst defaultAdditionalFields = parseSessionInput(\n\t\t\t\tctx?.context.options ?? options,\n\t\t\t\t{},\n\t\t\t);\n\t\t\tconst data: Omit<Session, \"id\"> = {\n\t\t\t\tipAddress:\n\t\t\t\t\tctx?.request || ctx?.headers\n\t\t\t\t\t\t? getIp(ctx?.request || ctx?.headers!, ctx?.context.options) || \"\"\n\t\t\t\t\t\t: \"\",\n\t\t\t\tuserAgent: headers?.get(\"user-agent\") || \"\",\n\t\t\t\t...rest,\n\t\t\t\t/**\n\t\t\t\t * If the user doesn't want to be remembered\n\t\t\t\t * set the session to expire in 1 day.\n\t\t\t\t * The cookie will be set to expire at the end of the session\n\t\t\t\t */\n\t\t\t\texpiresAt: dontRememberMe\n\t\t\t\t\t? getDate(60 * 60 * 24, \"sec\") // 1 day\n\t\t\t\t\t: getDate(sessionExpiration, \"sec\"),\n\t\t\t\tuserId,\n\t\t\t\ttoken: generateId(32),\n\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\tcreatedAt: new Date(),\n\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t...defaultAdditionalFields,\n\t\t\t\t...(overrideAll ? rest : {}),\n\t\t\t};\n\t\t\tconst res = await createWithHooks(\n\t\t\t\tdata,\n\t\t\t\t\"session\",\n\t\t\t\tsecondaryStorage\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tfn: async (sessionData) => {\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * store the session token for the user\n\t\t\t\t\t\t\t\t * so we can retrieve it later for listing sessions\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst currentList = await secondaryStorage.get(\n\t\t\t\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tlet list: { token: string; expiresAt: number }[] = [];\n\t\t\t\t\t\t\t\tconst now = Date.now();\n\n\t\t\t\t\t\t\t\tif (currentList) {\n\t\t\t\t\t\t\t\t\tlist = safeJSONParse(currentList) || [];\n\t\t\t\t\t\t\t\t\tlist = list.filter(\n\t\t\t\t\t\t\t\t\t\t(session) =>\n\t\t\t\t\t\t\t\t\t\t\tsession.expiresAt > now && session.token !== data.token,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst sorted = [\n\t\t\t\t\t\t\t\t\t...list,\n\t\t\t\t\t\t\t\t\t{ token: data.token, expiresAt: data.expiresAt.getTime() },\n\t\t\t\t\t\t\t\t].sort((a, b) => a.expiresAt - b.expiresAt);\n\t\t\t\t\t\t\t\tconst furthestSessionExp =\n\t\t\t\t\t\t\t\t\tsorted.at(-1)?.expiresAt ?? data.expiresAt.getTime();\n\t\t\t\t\t\t\t\tconst furthestSessionTTL = Math.max(\n\t\t\t\t\t\t\t\t\tMath.floor((furthestSessionExp - now) / 1000),\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (furthestSessionTTL > 0) {\n\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t\t\t\t\t\tJSON.stringify(sorted),\n\t\t\t\t\t\t\t\t\t\tfurthestSessionTTL,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst user = await adapter.findOne<User>({\n\t\t\t\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst sessionTTL = Math.max(\n\t\t\t\t\t\t\t\t\tMath.floor((data.expiresAt.getTime() - now) / 1000),\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (sessionTTL > 0) {\n\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\tdata.token,\n\t\t\t\t\t\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\t\t\t\t\t\tsession: sessionData,\n\t\t\t\t\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t\tsessionTTL,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn sessionData;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\texecuteMainFn: options.session?.storeSessionInDatabase,\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined,\n\t\t\t);\n\t\t\treturn res as Session;\n\t\t},\n\t\tfindSession: async (\n\t\t\ttoken: string,\n\t\t): Promise<{\n\t\t\tsession: Session & Record<string, any>;\n\t\t\tuser: User & Record<string, any>;\n\t\t} | null> => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst sessionStringified = await secondaryStorage.get(token);\n\t\t\t\tif (!sessionStringified && !options.session?.storeSessionInDatabase) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif (sessionStringified) {\n\t\t\t\t\tconst s = safeJSONParse<{\n\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\tuser: User;\n\t\t\t\t\t}>(sessionStringified);\n\t\t\t\t\tif (!s) return null;\n\t\t\t\t\tconst parsedSession = parseSessionOutput(ctx.options, {\n\t\t\t\t\t\t...s.session,\n\t\t\t\t\t\texpiresAt: new Date(s.session.expiresAt),\n\t\t\t\t\t\tcreatedAt: new Date(s.session.createdAt),\n\t\t\t\t\t\tupdatedAt: new Date(s.session.updatedAt),\n\t\t\t\t\t});\n\t\t\t\t\tconst parsedUser = parseUserOutput(ctx.options, {\n\t\t\t\t\t\t...s.user,\n\t\t\t\t\t\tcreatedAt: new Date(s.user.createdAt),\n\t\t\t\t\t\tupdatedAt: new Date(s.user.updatedAt),\n\t\t\t\t\t});\n\t\t\t\t\treturn {\n\t\t\t\t\t\tsession: parsedSession,\n\t\t\t\t\t\tuser: parsedUser,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst currentAdapter = await getCurrentAdapter(adapter);\n\t\t\tconst result = await currentAdapter.findOne<\n\t\t\t\tSession & { user: User | null }\n\t\t\t>({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: token,\n\t\t\t\t\t\tfield: \"token\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\tuser: true,\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (!result) return null;\n\n\t\t\tconst { user, ...session } = result;\n\t\t\tif (!user) return null;\n\t\t\tconst parsedSession = parseSessionOutput(ctx.options, session);\n\t\t\tconst parsedUser = parseUserOutput(ctx.options, user);\n\t\t\treturn {\n\t\t\t\tsession: parsedSession,\n\t\t\t\tuser: parsedUser,\n\t\t\t};\n\t\t},\n\t\tfindSessions: async (sessionTokens: string[]) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tconst sessions: {\n\t\t\t\t\tsession: Session;\n\t\t\t\t\tuser: User;\n\t\t\t\t}[] = [];\n\t\t\t\tfor (const sessionToken of sessionTokens) {\n\t\t\t\t\tconst sessionStringified = await secondaryStorage.get(sessionToken);\n\t\t\t\t\tif (sessionStringified) {\n\t\t\t\t\t\tconst s = safeJSONParse<{\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t}>(sessionStringified);\n\t\t\t\t\t\tif (!s) return [];\n\t\t\t\t\t\tconst session = {\n\t\t\t\t\t\t\tsession: {\n\t\t\t\t\t\t\t\t...s.session,\n\t\t\t\t\t\t\t\texpiresAt: new Date(s.session.expiresAt),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tuser: {\n\t\t\t\t\t\t\t\t...s.user,\n\t\t\t\t\t\t\t\tcreatedAt: new Date(s.user.createdAt),\n\t\t\t\t\t\t\t\tupdatedAt: new Date(s.user.updatedAt),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} as {\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t};\n\t\t\t\t\t\tsessions.push(session);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sessions;\n\t\t\t}\n\n\t\t\tconst sessions = await (await getCurrentAdapter(adapter)).findMany<\n\t\t\t\tSession & { user: User | null }\n\t\t\t>({\n\t\t\t\tmodel: \"session\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"token\",\n\t\t\t\t\t\tvalue: sessionTokens,\n\t\t\t\t\t\toperator: \"in\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\tuser: true,\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tif (!sessions.length) return [];\n\t\t\tif (sessions.some((session) => !session.user)) return [];\n\n\t\t\treturn sessions.map((_session) => {\n\t\t\t\tconst { user, ...session } = _session;\n\t\t\t\treturn {\n\t\t\t\t\tsession,\n\t\t\t\t\tuser: user!,\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\t\tupdateSession: async (\n\t\t\tsessionToken: string,\n\t\t\tsession: Partial<Session> & Record<string, any>,\n\t\t) => {\n\t\t\tconst updatedSession = await updateWithHooks<Session>(\n\t\t\t\tsession,\n\t\t\t\t[{ field: \"token\", value: sessionToken }],\n\t\t\t\t\"session\",\n\t\t\t\tsecondaryStorage\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tasync fn(data) {\n\t\t\t\t\t\t\t\tconst currentSession = await secondaryStorage.get(sessionToken);\n\t\t\t\t\t\t\t\tif (!currentSession) {\n\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst parsedSession = safeJSONParse<{\n\t\t\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t\t\t}>(currentSession);\n\t\t\t\t\t\t\t\tif (!parsedSession) return null;\n\n\t\t\t\t\t\t\t\tconst mergedSession = {\n\t\t\t\t\t\t\t\t\t...parsedSession.session,\n\t\t\t\t\t\t\t\t\t...data,\n\t\t\t\t\t\t\t\t\texpiresAt: new Date(\n\t\t\t\t\t\t\t\t\t\tdata.expiresAt ?? parsedSession.session.expiresAt,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tcreatedAt: new Date(parsedSession.session.createdAt),\n\t\t\t\t\t\t\t\t\tupdatedAt: new Date(\n\t\t\t\t\t\t\t\t\t\tdata.updatedAt ?? parsedSession.session.updatedAt,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tconst updatedSession = parseSessionOutput(\n\t\t\t\t\t\t\t\t\tctx.options,\n\t\t\t\t\t\t\t\t\tmergedSession,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\t\t\t\tconst expiresMs = new Date(updatedSession.expiresAt).getTime();\n\t\t\t\t\t\t\t\tconst sessionTTL = Math.max(\n\t\t\t\t\t\t\t\t\tMath.floor((expiresMs - now) / 1000),\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (sessionTTL > 0) {\n\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\tsessionToken,\n\t\t\t\t\t\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\t\t\t\t\t\tsession: updatedSession,\n\t\t\t\t\t\t\t\t\t\t\tuser: parsedSession.user,\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t\tsessionTTL,\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst listKey = `active-sessions-${updatedSession.userId}`;\n\t\t\t\t\t\t\t\t\tconst listRaw = await secondaryStorage.get(listKey);\n\t\t\t\t\t\t\t\t\tconst list: { token: string; expiresAt: number }[] = listRaw\n\t\t\t\t\t\t\t\t\t\t? safeJSONParse(listRaw) || []\n\t\t\t\t\t\t\t\t\t\t: [];\n\n\t\t\t\t\t\t\t\t\tconst filtered = list\n\t\t\t\t\t\t\t\t\t\t.filter(\n\t\t\t\t\t\t\t\t\t\t\t(s) => s.token !== sessionToken && s.expiresAt > now,\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t.concat([{ token: sessionToken, expiresAt: expiresMs }]);\n\n\t\t\t\t\t\t\t\t\tconst sorted = filtered.sort(\n\t\t\t\t\t\t\t\t\t\t(a, b) => a.expiresAt - b.expiresAt,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tconst furthestSessionExp = sorted.at(-1)?.expiresAt;\n\n\t\t\t\t\t\t\t\t\tif (furthestSessionExp && furthestSessionExp > now) {\n\t\t\t\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t\t\t\tlistKey,\n\t\t\t\t\t\t\t\t\t\t\tJSON.stringify(sorted),\n\t\t\t\t\t\t\t\t\t\t\tMath.floor((furthestSessionExp - now) / 1000),\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tawait secondaryStorage.delete(listKey);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn updatedSession;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\texecuteMainFn: options.session?.storeSessionInDatabase,\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined,\n\t\t\t);\n\t\t\treturn updatedSession;\n\t\t},\n\t\tdeleteSession: async (token: string) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\t// remove the session from the active sessions list\n\t\t\t\tconst data = await secondaryStorage.get(token);\n\t\t\t\tif (data) {\n\t\t\t\t\tconst { session } =\n\t\t\t\t\t\tsafeJSONParse<{\n\t\t\t\t\t\t\tsession: Session;\n\t\t\t\t\t\t\tuser: User;\n\t\t\t\t\t\t}>(data) ?? {};\n\t\t\t\t\tif (!session) {\n\t\t\t\t\t\tlogger.error(\"Session not found in secondary storage\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst userId = session.userId;\n\n\t\t\t\t\tconst currentList = await secondaryStorage.get(\n\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t);\n\t\t\t\t\tif (currentList) {\n\t\t\t\t\t\tconst list: { token: string; expiresAt: number }[] =\n\t\t\t\t\t\t\tsafeJSONParse(currentList) || [];\n\t\t\t\t\t\tconst now = Date.now();\n\n\t\t\t\t\t\tconst filtered = list.filter(\n\t\t\t\t\t\t\t(session) => session.expiresAt > now && session.token !== token,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst sorted = filtered.sort((a, b) => a.expiresAt - b.expiresAt);\n\t\t\t\t\t\tconst furthestSessionExp = sorted.at(-1)?.expiresAt;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tfiltered.length > 0 &&\n\t\t\t\t\t\t\tfurthestSessionExp &&\n\t\t\t\t\t\t\tfurthestSessionExp > Date.now()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tawait secondaryStorage.set(\n\t\t\t\t\t\t\t\t`active-sessions-${userId}`,\n\t\t\t\t\t\t\t\tJSON.stringify(filtered),\n\t\t\t\t\t\t\t\tMath.floor((furthestSessionExp - now) / 1000),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tawait secondaryStorage.delete(`active-sessions-${userId}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.error(\"Active sessions list not found in secondary storage\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tawait secondaryStorage.delete(token);\n\n\t\t\t\tif (\n\t\t\t\t\t!options.session?.storeSessionInDatabase ||\n\t\t\t\t\tctx.options.session?.preserveSessionInDatabase\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"token\", value: token }],\n\t\t\t\t\"session\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteAccounts: async (userId: string) => {\n\t\t\tawait deleteManyWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteAccount: async (accountId: string) => {\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"id\", value: accountId }],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteSessions: async (userIdOrSessionTokens: string | string[]) => {\n\t\t\tif (secondaryStorage) {\n\t\t\t\tif (typeof userIdOrSessionTokens === \"string\") {\n\t\t\t\t\tconst activeSession = await secondaryStorage.get(\n\t\t\t\t\t\t`active-sessions-${userIdOrSessionTokens}`,\n\t\t\t\t\t);\n\t\t\t\t\tconst sessions = activeSession\n\t\t\t\t\t\t? safeJSONParse<{ token: string }[]>(activeSession)\n\t\t\t\t\t\t: [];\n\t\t\t\t\tif (!sessions) return;\n\t\t\t\t\tfor (const session of sessions) {\n\t\t\t\t\t\tawait secondaryStorage.delete(session.token);\n\t\t\t\t\t}\n\t\t\t\t\tawait secondaryStorage.delete(\n\t\t\t\t\t\t`active-sessions-${userIdOrSessionTokens}`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tfor (const sessionToken of userIdOrSessionTokens) {\n\t\t\t\t\t\tconst session = await secondaryStorage.get(sessionToken);\n\t\t\t\t\t\tif (session) {\n\t\t\t\t\t\t\tawait secondaryStorage.delete(sessionToken);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!options.session?.storeSessionInDatabase ||\n\t\t\t\t\tctx.options.session?.preserveSessionInDatabase\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tawait deleteManyWithHooks(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: Array.isArray(userIdOrSessionTokens) ? \"token\" : \"userId\",\n\t\t\t\t\t\tvalue: userIdOrSessionTokens,\n\t\t\t\t\t\toperator: Array.isArray(userIdOrSessionTokens) ? \"in\" : undefined,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"session\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tfindOAuthUser: async (\n\t\t\temail: string,\n\t\t\taccountId: string,\n\t\t\tproviderId: string,\n\t\t) => {\n\t\t\t// we need to find account first to avoid missing user if the email changed with the provider for the same account\n\t\t\tconst account = await (await getCurrentAdapter(adapter)).findOne<\n\t\t\t\tAccount & { user: User | null }\n\t\t\t>({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: accountId,\n\t\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: providerId,\n\t\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\tuser: true,\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (account) {\n\t\t\t\tif (account.user) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tuser: account.user,\n\t\t\t\t\t\tlinkedAccount: account,\n\t\t\t\t\t\taccounts: [account],\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne<User>({\n\t\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t});\n\t\t\t\t\tif (user) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tuser,\n\t\t\t\t\t\t\tlinkedAccount: account,\n\t\t\t\t\t\t\taccounts: [account],\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne<User>({\n\t\t\t\t\tmodel: \"user\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t});\n\t\t\t\tif (user) {\n\t\t\t\t\tconst accounts = await (\n\t\t\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t\t\t).findMany<Account>({\n\t\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\t\twhere: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvalue: user.id,\n\t\t\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t});\n\t\t\t\t\treturn {\n\t\t\t\t\t\tuser,\n\t\t\t\t\t\tlinkedAccount: null,\n\t\t\t\t\t\taccounts: accounts || [],\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tfindUserByEmail: async (\n\t\t\temail: string,\n\t\t\toptions?: { includeAccounts: boolean } | undefined,\n\t\t) => {\n\t\t\tconst currentAdapter = await getCurrentAdapter(adapter);\n\t\t\tconst result = await currentAdapter.findOne<\n\t\t\t\tUser & { account: Account[] | undefined }\n\t\t\t>({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tjoin: {\n\t\t\t\t\t...(options?.includeAccounts ? { account: true } : {}),\n\t\t\t\t},\n\t\t\t});\n\t\t\tif (!result) return null;\n\t\t\tconst { account: accounts, ...user } = result;\n\t\t\treturn {\n\t\t\t\tuser,\n\t\t\t\taccounts: accounts ?? [],\n\t\t\t};\n\t\t},\n\t\tfindUserById: async (userId: string) => {\n\t\t\tif (!userId) return null;\n\t\t\tconst user = await (await getCurrentAdapter(adapter)).findOne<User>({\n\t\t\t\tmodel: \"user\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn user;\n\t\t},\n\t\tlinkAccount: async (\n\t\t\taccount: Omit<Account, \"id\" | \"createdAt\" | \"updatedAt\"> &\n\t\t\t\tPartial<Account>,\n\t\t) => {\n\t\t\tconst _account = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...account,\n\t\t\t\t},\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn _account;\n\t\t},\n\t\tupdateUser: async (\n\t\t\tuserId: string,\n\t\t\tdata: Partial<User> & Record<string, any>,\n\t\t) => {\n\t\t\tconst user = await updateWithHooks<User>(\n\t\t\t\tdata,\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\tawait refreshUserSessions(user);\n\t\t\treturn user;\n\t\t},\n\t\tupdateUserByEmail: async (\n\t\t\temail: string,\n\t\t\tdata: Partial<User & Record<string, any>>,\n\t\t) => {\n\t\t\tconst user = await updateWithHooks<User>(\n\t\t\t\tdata,\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"email\",\n\t\t\t\t\t\tvalue: email.toLowerCase(),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"user\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\tawait refreshUserSessions(user);\n\t\t\treturn user;\n\t\t},\n\t\tupdatePassword: async (userId: string, password: string) => {\n\t\t\tawait updateManyWithHooks(\n\t\t\t\t{\n\t\t\t\t\tpassword,\n\t\t\t\t},\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\t\tvalue: \"credential\",\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tfindAccounts: async (userId: string) => {\n\t\t\tconst accounts = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Account>({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn accounts;\n\t\t},\n\t\tfindAccount: async (accountId: string) => {\n\t\t\tconst account = await (await getCurrentAdapter(adapter)).findOne<Account>(\n\t\t\t\t{\n\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\t\t\tvalue: accountId,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t);\n\t\t\treturn account;\n\t\t},\n\t\tfindAccountByProviderId: async (accountId: string, providerId: string) => {\n\t\t\tconst account = await (await getCurrentAdapter(adapter)).findOne<Account>(\n\t\t\t\t{\n\t\t\t\t\tmodel: \"account\",\n\t\t\t\t\twhere: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"accountId\",\n\t\t\t\t\t\t\tvalue: accountId,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"providerId\",\n\t\t\t\t\t\t\tvalue: providerId,\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t);\n\t\t\treturn account;\n\t\t},\n\t\tfindAccountByUserId: async (userId: string) => {\n\t\t\tconst account = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Account>({\n\t\t\t\tmodel: \"account\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"userId\",\n\t\t\t\t\t\tvalue: userId,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t});\n\t\t\treturn account;\n\t\t},\n\t\tupdateAccount: async (id: string, data: Partial<Account>) => {\n\t\t\tconst account = await updateWithHooks<Account>(\n\t\t\t\tdata,\n\t\t\t\t[{ field: \"id\", value: id }],\n\t\t\t\t\"account\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn account;\n\t\t},\n\t\tcreateVerificationValue: async (\n\t\t\tdata: Omit<Verification, \"createdAt\" | \"id\" | \"updatedAt\"> &\n\t\t\t\tPartial<Verification>,\n\t\t) => {\n\t\t\tconst verification = await createWithHooks(\n\t\t\t\t{\n\t\t\t\t\t// todo: we should remove auto setting createdAt and updatedAt in the next major release, since the db generators already handle that\n\t\t\t\t\tcreatedAt: new Date(),\n\t\t\t\t\tupdatedAt: new Date(),\n\t\t\t\t\t...data,\n\t\t\t\t},\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn verification as Verification;\n\t\t},\n\t\tfindVerificationValue: async (identifier: string) => {\n\t\t\tconst verification = await (\n\t\t\t\tawait getCurrentAdapter(adapter)\n\t\t\t).findMany<Verification>({\n\t\t\t\tmodel: \"verification\",\n\t\t\t\twhere: [\n\t\t\t\t\t{\n\t\t\t\t\t\tfield: \"identifier\",\n\t\t\t\t\t\tvalue: identifier,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tsortBy: {\n\t\t\t\t\tfield: \"createdAt\",\n\t\t\t\t\tdirection: \"desc\",\n\t\t\t\t},\n\t\t\t\tlimit: 1,\n\t\t\t});\n\t\t\tif (!options.verification?.disableCleanup) {\n\t\t\t\tawait deleteManyWithHooks(\n\t\t\t\t\t[\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield: \"expiresAt\",\n\t\t\t\t\t\t\tvalue: new Date(),\n\t\t\t\t\t\t\toperator: \"lt\",\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\t\"verification\",\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst lastVerification = verification[0];\n\t\t\treturn lastVerification as Verification | null;\n\t\t},\n\t\tdeleteVerificationValue: async (id: string) => {\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"id\", value: id }],\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tdeleteVerificationByIdentifier: async (identifier: string) => {\n\t\t\tawait deleteWithHooks(\n\t\t\t\t[{ field: \"identifier\", value: identifier }],\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t},\n\t\tupdateVerificationValue: async (\n\t\t\tid: string,\n\t\t\tdata: Partial<Verification>,\n\t\t) => {\n\t\t\tconst verification = await updateWithHooks<Verification>(\n\t\t\t\tdata,\n\t\t\t\t[{ field: \"id\", value: id }],\n\t\t\t\t\"verification\",\n\t\t\t\tundefined,\n\t\t\t);\n\t\t\treturn verification;\n\t\t},\n\t};\n};\n"],"mappings":"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"}