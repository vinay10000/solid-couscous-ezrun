{"version":3,"file":"drizzle-adapter.mjs","names":["lazyOptions: BetterAuthOptions | null","db","clause: SQL<unknown>[]","includes:\n\t\t\t\t\t\t\t\t| Record<string, { limit: number } | boolean>\n\t\t\t\t\t\t\t\t| undefined","pluralJoinResults: string[]","model","res","limit","orderBy: SQL<unknown>[] | undefined","count","adapterOptions: AdapterFactoryOptions | null"],"sources":["../../../src/adapters/drizzle-adapter/drizzle-adapter.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tAdapterFactoryCustomizeAdapterCreator,\n\tAdapterFactoryOptions,\n\tDBAdapter,\n\tDBAdapterDebugLogOption,\n\tWhere,\n} from \"@better-auth/core/db/adapter\";\nimport { createAdapterFactory } from \"@better-auth/core/db/adapter\";\nimport { logger } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\nimport type { SQL } from \"drizzle-orm\";\nimport {\n\tand,\n\tasc,\n\tcount,\n\tdesc,\n\teq,\n\tgt,\n\tgte,\n\tinArray,\n\tlike,\n\tlt,\n\tlte,\n\tne,\n\tnotInArray,\n\tor,\n\tsql,\n} from \"drizzle-orm\";\n\nexport interface DB {\n\t[key: string]: any;\n}\n\nexport interface DrizzleAdapterConfig {\n\t/**\n\t * The schema object that defines the tables and fields\n\t */\n\tschema?: Record<string, any> | undefined;\n\t/**\n\t * The database provider\n\t */\n\tprovider: \"pg\" | \"mysql\" | \"sqlite\";\n\t/**\n\t * If the table names in the schema are plural\n\t * set this to true. For example, if the schema\n\t * has an object with a key \"users\" instead of \"user\"\n\t */\n\tusePlural?: boolean | undefined;\n\t/**\n\t * Enable debug logs for the adapter\n\t *\n\t * @default false\n\t */\n\tdebugLogs?: DBAdapterDebugLogOption | undefined;\n\t/**\n\t * By default snake case is used for table and field names\n\t * when the CLI is used to generate the schema. If you want\n\t * to use camel case, set this to true.\n\t * @default false\n\t */\n\tcamelCase?: boolean | undefined;\n\t/**\n\t * Whether to execute multiple operations in a transaction.\n\t *\n\t * If the database doesn't support transactions,\n\t * set this to `false` and operations will be executed sequentially.\n\t * @default false\n\t */\n\ttransaction?: boolean | undefined;\n}\n\nexport const drizzleAdapter = (db: DB, config: DrizzleAdapterConfig) => {\n\tlet lazyOptions: BetterAuthOptions | null = null;\n\tconst createCustomAdapter =\n\t\t(db: DB): AdapterFactoryCustomizeAdapterCreator =>\n\t\t({ getFieldName, options }) => {\n\t\t\tfunction getSchema(model: string) {\n\t\t\t\tconst schema = config.schema || db._.fullSchema;\n\t\t\t\tif (!schema) {\n\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\"Drizzle adapter failed to initialize. Schema not found. Please provide a schema object in the adapter options object.\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst schemaModel = schema[model];\n\t\t\t\tif (!schemaModel) {\n\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t`[# Drizzle Adapter]: The model \"${model}\" was not found in the schema object. Please pass the schema directly to the adapter options.`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn schemaModel;\n\t\t\t}\n\t\t\tconst withReturning = async (\n\t\t\t\tmodel: string,\n\t\t\t\tbuilder: any,\n\t\t\t\tdata: Record<string, any>,\n\t\t\t\twhere?: Where[] | undefined,\n\t\t\t) => {\n\t\t\t\tif (config.provider !== \"mysql\") {\n\t\t\t\t\tconst c = await builder.returning();\n\t\t\t\t\treturn c[0];\n\t\t\t\t}\n\t\t\t\tawait builder.execute();\n\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\tconst builderVal = builder.config?.values;\n\t\t\t\tif (where?.length) {\n\t\t\t\t\t// If we're updating a field that's in the where clause, use the new value\n\t\t\t\t\tconst updatedWhere = where.map((w) => {\n\t\t\t\t\t\t// If this field was updated, use the new value for lookup\n\t\t\t\t\t\tif (data[w.field] !== undefined) {\n\t\t\t\t\t\t\treturn { ...w, value: data[w.field] };\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn w;\n\t\t\t\t\t});\n\n\t\t\t\t\tconst clause = convertWhereClause(updatedWhere, model);\n\t\t\t\t\tconst res = await db\n\t\t\t\t\t\t.select()\n\t\t\t\t\t\t.from(schemaModel)\n\t\t\t\t\t\t.where(...clause);\n\t\t\t\t\treturn res[0];\n\t\t\t\t} else if (builderVal && builderVal[0]?.id?.value) {\n\t\t\t\t\tlet tId = builderVal[0]?.id?.value;\n\t\t\t\t\tif (!tId) {\n\t\t\t\t\t\t//get last inserted id\n\t\t\t\t\t\tconst lastInsertId = await db\n\t\t\t\t\t\t\t.select({ id: sql`LAST_INSERT_ID()` })\n\t\t\t\t\t\t\t.from(schemaModel)\n\t\t\t\t\t\t\t.orderBy(desc(schemaModel.id))\n\t\t\t\t\t\t\t.limit(1);\n\t\t\t\t\t\ttId = lastInsertId[0].id;\n\t\t\t\t\t}\n\t\t\t\t\tconst res = await db\n\t\t\t\t\t\t.select()\n\t\t\t\t\t\t.from(schemaModel)\n\t\t\t\t\t\t.where(eq(schemaModel.id, tId))\n\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t.execute();\n\t\t\t\t\treturn res[0];\n\t\t\t\t} else if (data.id) {\n\t\t\t\t\tconst res = await db\n\t\t\t\t\t\t.select()\n\t\t\t\t\t\t.from(schemaModel)\n\t\t\t\t\t\t.where(eq(schemaModel.id, data.id))\n\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t.execute();\n\t\t\t\t\treturn res[0];\n\t\t\t\t} else {\n\t\t\t\t\t// If the user doesn't have `id` as a field, then this will fail.\n\t\t\t\t\t// We expect that they defined `id` in all of their models.\n\t\t\t\t\tif (!(\"id\" in schemaModel)) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`The model \"${model}\" does not have an \"id\" field. Please use the \"id\" field as your primary key.`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst res = await db\n\t\t\t\t\t\t.select()\n\t\t\t\t\t\t.from(schemaModel)\n\t\t\t\t\t\t.orderBy(desc(schemaModel.id))\n\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t.execute();\n\t\t\t\t\treturn res[0];\n\t\t\t\t}\n\t\t\t};\n\t\t\tfunction convertWhereClause(where: Where[], model: string) {\n\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\tif (!where) return [];\n\t\t\t\tif (where.length === 1) {\n\t\t\t\t\tconst w = where[0];\n\t\t\t\t\tif (!w) {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t\tconst field = getFieldName({ model, field: w.field });\n\t\t\t\t\tif (!schemaModel[field]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`The field \"${w.field}\" does not exist in the schema for the model \"${model}\". Please update your schema.`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (w.operator === \"in\") {\n\t\t\t\t\t\tif (!Array.isArray(w.value)) {\n\t\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t\t`The value for the field \"${w.field}\" must be an array when using the \"in\" operator.`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [inArray(schemaModel[field], w.value)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"not_in\") {\n\t\t\t\t\t\tif (!Array.isArray(w.value)) {\n\t\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t\t`The value for the field \"${w.field}\" must be an array when using the \"not_in\" operator.`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [notInArray(schemaModel[field], w.value)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"contains\") {\n\t\t\t\t\t\treturn [like(schemaModel[field], `%${w.value}%`)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"starts_with\") {\n\t\t\t\t\t\treturn [like(schemaModel[field], `${w.value}%`)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"ends_with\") {\n\t\t\t\t\t\treturn [like(schemaModel[field], `%${w.value}`)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"lt\") {\n\t\t\t\t\t\treturn [lt(schemaModel[field], w.value)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"lte\") {\n\t\t\t\t\t\treturn [lte(schemaModel[field], w.value)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"ne\") {\n\t\t\t\t\t\treturn [ne(schemaModel[field], w.value)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"gt\") {\n\t\t\t\t\t\treturn [gt(schemaModel[field], w.value)];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (w.operator === \"gte\") {\n\t\t\t\t\t\treturn [gte(schemaModel[field], w.value)];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [eq(schemaModel[field], w.value)];\n\t\t\t\t}\n\t\t\t\tconst andGroup = where.filter(\n\t\t\t\t\t(w) => w.connector === \"AND\" || !w.connector,\n\t\t\t\t);\n\t\t\t\tconst orGroup = where.filter((w) => w.connector === \"OR\");\n\n\t\t\t\tconst andClause = and(\n\t\t\t\t\t...andGroup.map((w) => {\n\t\t\t\t\t\tconst field = getFieldName({ model, field: w.field });\n\t\t\t\t\t\tif (w.operator === \"in\") {\n\t\t\t\t\t\t\tif (!Array.isArray(w.value)) {\n\t\t\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t\t\t`The value for the field \"${w.field}\" must be an array when using the \"in\" operator.`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn inArray(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"not_in\") {\n\t\t\t\t\t\t\tif (!Array.isArray(w.value)) {\n\t\t\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t\t\t`The value for the field \"${w.field}\" must be an array when using the \"not_in\" operator.`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn notInArray(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"contains\") {\n\t\t\t\t\t\t\treturn like(schemaModel[field], `%${w.value}%`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"starts_with\") {\n\t\t\t\t\t\t\treturn like(schemaModel[field], `${w.value}%`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"ends_with\") {\n\t\t\t\t\t\t\treturn like(schemaModel[field], `%${w.value}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"lt\") {\n\t\t\t\t\t\t\treturn lt(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"lte\") {\n\t\t\t\t\t\t\treturn lte(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"gt\") {\n\t\t\t\t\t\t\treturn gt(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"gte\") {\n\t\t\t\t\t\t\treturn gte(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"ne\") {\n\t\t\t\t\t\t\treturn ne(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn eq(schemaModel[field], w.value);\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t\tconst orClause = or(\n\t\t\t\t\t...orGroup.map((w) => {\n\t\t\t\t\t\tconst field = getFieldName({ model, field: w.field });\n\t\t\t\t\t\tif (w.operator === \"in\") {\n\t\t\t\t\t\t\tif (!Array.isArray(w.value)) {\n\t\t\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t\t\t`The value for the field \"${w.field}\" must be an array when using the \"in\" operator.`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn inArray(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"not_in\") {\n\t\t\t\t\t\t\tif (!Array.isArray(w.value)) {\n\t\t\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t\t\t`The value for the field \"${w.field}\" must be an array when using the \"not_in\" operator.`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn notInArray(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"contains\") {\n\t\t\t\t\t\t\treturn like(schemaModel[field], `%${w.value}%`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"starts_with\") {\n\t\t\t\t\t\t\treturn like(schemaModel[field], `${w.value}%`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"ends_with\") {\n\t\t\t\t\t\t\treturn like(schemaModel[field], `%${w.value}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"lt\") {\n\t\t\t\t\t\t\treturn lt(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"lte\") {\n\t\t\t\t\t\t\treturn lte(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"gt\") {\n\t\t\t\t\t\t\treturn gt(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"gte\") {\n\t\t\t\t\t\t\treturn gte(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w.operator === \"ne\") {\n\t\t\t\t\t\t\treturn ne(schemaModel[field], w.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn eq(schemaModel[field], w.value);\n\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\tconst clause: SQL<unknown>[] = [];\n\n\t\t\t\tif (andGroup.length) clause.push(andClause!);\n\t\t\t\tif (orGroup.length) clause.push(orClause!);\n\t\t\t\treturn clause;\n\t\t\t}\n\t\t\tfunction checkMissingFields(\n\t\t\t\tschema: Record<string, any>,\n\t\t\t\tmodel: string,\n\t\t\t\tvalues: Record<string, any>,\n\t\t\t) {\n\t\t\t\tif (!schema) {\n\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\"Drizzle adapter failed to initialize. Drizzle Schema not found. Please provide a schema object in the adapter options object.\",\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tfor (const key in values) {\n\t\t\t\t\tif (!schema[key]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`The field \"${key}\" does not exist in the \"${model}\" Drizzle schema. Please update your drizzle schema or re-generate using \"npx @better-auth/cli@latest generate\".`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tasync create({ model, data: values }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tcheckMissingFields(schemaModel, model, values);\n\t\t\t\t\tconst builder = db.insert(schemaModel).values(values);\n\t\t\t\t\tconst returned = await withReturning(model, builder, values);\n\t\t\t\t\treturn returned;\n\t\t\t\t},\n\t\t\t\tasync findOne({ model, where, join }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tconst clause = convertWhereClause(where, model);\n\n\t\t\t\t\tif (options.experimental?.joins) {\n\t\t\t\t\t\tif (!db.query || !db.query[model]) {\n\t\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\t`[# Drizzle Adapter]: The model \"${model}\" was not found in the query object. Please update your Drizzle schema to include relations or re-generate using \"npx @better-auth/cli@latest generate\".`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tlogger.info(\"Falling back to regular query\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet includes:\n\t\t\t\t\t\t\t\t| Record<string, { limit: number } | boolean>\n\t\t\t\t\t\t\t\t| undefined;\n\n\t\t\t\t\t\t\tconst pluralJoinResults: string[] = [];\n\t\t\t\t\t\t\tif (join) {\n\t\t\t\t\t\t\t\tincludes = {};\n\t\t\t\t\t\t\t\tconst joinEntries = Object.entries(join);\n\t\t\t\t\t\t\t\tfor (const [model, joinAttr] of joinEntries) {\n\t\t\t\t\t\t\t\t\tconst limit =\n\t\t\t\t\t\t\t\t\t\tjoinAttr.limit ??\n\t\t\t\t\t\t\t\t\t\toptions.advanced?.database?.defaultFindManyLimit ??\n\t\t\t\t\t\t\t\t\t\t100;\n\t\t\t\t\t\t\t\t\tconst isUnique = joinAttr.relation === \"one-to-one\";\n\t\t\t\t\t\t\t\t\tconst pluralSuffix = isUnique || config.usePlural ? \"\" : \"s\";\n\t\t\t\t\t\t\t\t\tincludes[`${model}${pluralSuffix}`] = isUnique\n\t\t\t\t\t\t\t\t\t\t? true\n\t\t\t\t\t\t\t\t\t\t: { limit };\n\t\t\t\t\t\t\t\t\tif (!isUnique) {\n\t\t\t\t\t\t\t\t\t\tpluralJoinResults.push(`${model}${pluralSuffix}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst query = db.query[model].findFirst({\n\t\t\t\t\t\t\t\twhere: clause[0],\n\t\t\t\t\t\t\t\twith: includes,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tconst res = await query;\n\n\t\t\t\t\t\t\tif (res) {\n\t\t\t\t\t\t\t\tfor (const pluralJoinResult of pluralJoinResults) {\n\t\t\t\t\t\t\t\t\tconst singularKey = !config.usePlural\n\t\t\t\t\t\t\t\t\t\t? pluralJoinResult.slice(0, -1)\n\t\t\t\t\t\t\t\t\t\t: pluralJoinResult;\n\t\t\t\t\t\t\t\t\tres[singularKey] = res[pluralJoinResult];\n\t\t\t\t\t\t\t\t\tif (pluralJoinResult !== singularKey) {\n\t\t\t\t\t\t\t\t\t\tdelete res[pluralJoinResult];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst query = db\n\t\t\t\t\t\t.select()\n\t\t\t\t\t\t.from(schemaModel)\n\t\t\t\t\t\t.where(...clause);\n\n\t\t\t\t\tconst res = await query;\n\n\t\t\t\t\tif (!res.length) return null;\n\t\t\t\t\treturn res[0];\n\t\t\t\t},\n\t\t\t\tasync findMany({ model, where, sortBy, limit, offset, join }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tconst clause = where ? convertWhereClause(where, model) : [];\n\t\t\t\t\tconst sortFn = sortBy?.direction === \"desc\" ? desc : asc;\n\n\t\t\t\t\tif (options.experimental?.joins) {\n\t\t\t\t\t\tif (!db.query[model]) {\n\t\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\t`[# Drizzle Adapter]: The model \"${model}\" was not found in the query object. Please update your Drizzle schema to include relations or re-generate using \"npx @better-auth/cli@latest generate\".`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tlogger.info(\"Falling back to regular query\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet includes:\n\t\t\t\t\t\t\t\t| Record<string, { limit: number } | boolean>\n\t\t\t\t\t\t\t\t| undefined;\n\n\t\t\t\t\t\t\tconst pluralJoinResults: string[] = [];\n\t\t\t\t\t\t\tif (join) {\n\t\t\t\t\t\t\t\tincludes = {};\n\t\t\t\t\t\t\t\tconst joinEntries = Object.entries(join);\n\t\t\t\t\t\t\t\tfor (const [model, joinAttr] of joinEntries) {\n\t\t\t\t\t\t\t\t\tconst isUnique = joinAttr.relation === \"one-to-one\";\n\t\t\t\t\t\t\t\t\tconst limit =\n\t\t\t\t\t\t\t\t\t\tjoinAttr.limit ??\n\t\t\t\t\t\t\t\t\t\toptions.advanced?.database?.defaultFindManyLimit ??\n\t\t\t\t\t\t\t\t\t\t100;\n\t\t\t\t\t\t\t\t\tconst pluralSuffix = isUnique || config.usePlural ? \"\" : \"s\";\n\t\t\t\t\t\t\t\t\tincludes[`${model}${pluralSuffix}`] = isUnique\n\t\t\t\t\t\t\t\t\t\t? true\n\t\t\t\t\t\t\t\t\t\t: { limit };\n\t\t\t\t\t\t\t\t\tif (!isUnique)\n\t\t\t\t\t\t\t\t\t\tpluralJoinResults.push(`${model}${pluralSuffix}`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet orderBy: SQL<unknown>[] | undefined = undefined;\n\t\t\t\t\t\t\tif (sortBy?.field) {\n\t\t\t\t\t\t\t\torderBy = [\n\t\t\t\t\t\t\t\t\tsortFn(\n\t\t\t\t\t\t\t\t\t\tschemaModel[getFieldName({ model, field: sortBy?.field })],\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst query = db.query[model].findMany({\n\t\t\t\t\t\t\t\twhere: clause[0],\n\t\t\t\t\t\t\t\twith: includes,\n\t\t\t\t\t\t\t\tlimit: limit ?? 100,\n\t\t\t\t\t\t\t\toffset: offset ?? 0,\n\t\t\t\t\t\t\t\torderBy,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tconst res = await query;\n\t\t\t\t\t\t\tif (res) {\n\t\t\t\t\t\t\t\tfor (const item of res) {\n\t\t\t\t\t\t\t\t\tfor (const pluralJoinResult of pluralJoinResults) {\n\t\t\t\t\t\t\t\t\t\tconst singularKey = !config.usePlural\n\t\t\t\t\t\t\t\t\t\t\t? pluralJoinResult.slice(0, -1)\n\t\t\t\t\t\t\t\t\t\t\t: pluralJoinResult;\n\t\t\t\t\t\t\t\t\t\tif (singularKey === pluralJoinResult) continue;\n\t\t\t\t\t\t\t\t\t\titem[singularKey] = item[pluralJoinResult];\n\t\t\t\t\t\t\t\t\t\tdelete item[pluralJoinResult];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlet builder = db.select().from(schemaModel);\n\n\t\t\t\t\tconst effectiveLimit = limit;\n\t\t\t\t\tconst effectiveOffset = offset;\n\n\t\t\t\t\tif (typeof effectiveLimit !== \"undefined\") {\n\t\t\t\t\t\tbuilder = builder.limit(effectiveLimit);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof effectiveOffset !== \"undefined\") {\n\t\t\t\t\t\tbuilder = builder.offset(effectiveOffset);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sortBy?.field) {\n\t\t\t\t\t\tbuilder = builder.orderBy(\n\t\t\t\t\t\t\tsortFn(\n\t\t\t\t\t\t\t\tschemaModel[getFieldName({ model, field: sortBy?.field })],\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst res = await builder.where(...clause);\n\t\t\t\t\treturn res;\n\t\t\t\t},\n\t\t\t\tasync count({ model, where }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tconst clause = where ? convertWhereClause(where, model) : [];\n\t\t\t\t\tconst res = await db\n\t\t\t\t\t\t.select({ count: count() })\n\t\t\t\t\t\t.from(schemaModel)\n\t\t\t\t\t\t.where(...clause);\n\t\t\t\t\treturn res[0].count;\n\t\t\t\t},\n\t\t\t\tasync update({ model, where, update: values }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tconst clause = convertWhereClause(where, model);\n\t\t\t\t\tconst builder = db\n\t\t\t\t\t\t.update(schemaModel)\n\t\t\t\t\t\t.set(values)\n\t\t\t\t\t\t.where(...clause);\n\t\t\t\t\treturn await withReturning(model, builder, values as any, where);\n\t\t\t\t},\n\t\t\t\tasync updateMany({ model, where, update: values }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tconst clause = convertWhereClause(where, model);\n\t\t\t\t\tconst builder = db\n\t\t\t\t\t\t.update(schemaModel)\n\t\t\t\t\t\t.set(values)\n\t\t\t\t\t\t.where(...clause);\n\t\t\t\t\treturn await builder;\n\t\t\t\t},\n\t\t\t\tasync delete({ model, where }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tconst clause = convertWhereClause(where, model);\n\t\t\t\t\tconst builder = db.delete(schemaModel).where(...clause);\n\t\t\t\t\treturn await builder;\n\t\t\t\t},\n\t\t\t\tasync deleteMany({ model, where }) {\n\t\t\t\t\tconst schemaModel = getSchema(model);\n\t\t\t\t\tconst clause = convertWhereClause(where, model);\n\t\t\t\t\tconst builder = db.delete(schemaModel).where(...clause);\n\t\t\t\t\tconst res = await builder;\n\t\t\t\t\tlet count = 0;\n\t\t\t\t\tif (res && \"rowCount\" in res) count = res.rowCount;\n\t\t\t\t\telse if (Array.isArray(res)) count = res.length;\n\t\t\t\t\telse if (\n\t\t\t\t\t\tres &&\n\t\t\t\t\t\t(\"affectedRows\" in res || \"rowsAffected\" in res || \"changes\" in res)\n\t\t\t\t\t)\n\t\t\t\t\t\tcount = res.affectedRows ?? res.rowsAffected ?? res.changes;\n\t\t\t\t\tif (typeof count !== \"number\") {\n\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\"[Drizzle Adapter] The result of the deleteMany operation is not a number. This is likely a bug in the adapter. Please report this issue to the Better Auth team.\",\n\t\t\t\t\t\t\t{ res, model, where },\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn count;\n\t\t\t\t},\n\t\t\t\toptions: config,\n\t\t\t};\n\t\t};\n\tlet adapterOptions: AdapterFactoryOptions | null = null;\n\tadapterOptions = {\n\t\tconfig: {\n\t\t\tadapterId: \"drizzle\",\n\t\t\tadapterName: \"Drizzle Adapter\",\n\t\t\tusePlural: config.usePlural ?? false,\n\t\t\tdebugLogs: config.debugLogs ?? false,\n\t\t\tsupportsUUIDs: config.provider === \"pg\" ? true : false,\n\t\t\tsupportsJSON:\n\t\t\t\tconfig.provider === \"pg\" // even though mysql also supports it, mysql requires to pass stringified json anyway.\n\t\t\t\t\t? true\n\t\t\t\t\t: false,\n\t\t\tsupportsArrays: config.provider === \"pg\" ? true : false,\n\t\t\ttransaction:\n\t\t\t\t(config.transaction ?? false)\n\t\t\t\t\t? (cb) =>\n\t\t\t\t\t\t\tdb.transaction((tx: DB) => {\n\t\t\t\t\t\t\t\tconst adapter = createAdapterFactory({\n\t\t\t\t\t\t\t\t\tconfig: adapterOptions!.config,\n\t\t\t\t\t\t\t\t\tadapter: createCustomAdapter(tx),\n\t\t\t\t\t\t\t\t})(lazyOptions!);\n\t\t\t\t\t\t\t\treturn cb(adapter);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t: false,\n\t\t},\n\t\tadapter: createCustomAdapter(db),\n\t};\n\tconst adapter = createAdapterFactory(adapterOptions);\n\treturn (options: BetterAuthOptions): DBAdapter<BetterAuthOptions> => {\n\t\tlazyOptions = options;\n\t\treturn adapter(options);\n\t};\n};\n"],"mappings":"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"}