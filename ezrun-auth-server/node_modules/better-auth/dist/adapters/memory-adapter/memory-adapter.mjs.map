{"version":3,"file":"memory-adapter.mjs","names":["lazyOptions: BetterAuthOptions | null","model","where","nested: Record<string, any>"],"sources":["../../../src/adapters/memory-adapter/memory-adapter.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tCleanedWhere,\n\tDBAdapterDebugLogOption,\n\tJoinConfig,\n} from \"@better-auth/core/db/adapter\";\nimport { createAdapterFactory } from \"@better-auth/core/db/adapter\";\nimport { logger } from \"@better-auth/core/env\";\n\nexport interface MemoryDB {\n\t[key: string]: any[];\n}\n\nexport interface MemoryAdapterConfig {\n\tdebugLogs?: DBAdapterDebugLogOption | undefined;\n}\n\nexport const memoryAdapter = (\n\tdb: MemoryDB,\n\tconfig?: MemoryAdapterConfig | undefined,\n) => {\n\tlet lazyOptions: BetterAuthOptions | null = null;\n\tconst adapterCreator = createAdapterFactory({\n\t\tconfig: {\n\t\t\tadapterId: \"memory\",\n\t\t\tadapterName: \"Memory Adapter\",\n\t\t\tusePlural: false,\n\t\t\tdebugLogs: config?.debugLogs || false,\n\t\t\tsupportsArrays: true,\n\t\t\tcustomTransformInput(props) {\n\t\t\t\tconst useNumberId =\n\t\t\t\t\tprops.options.advanced?.database?.useNumberId ||\n\t\t\t\t\tprops.options.advanced?.database?.generateId === \"serial\";\n\t\t\t\tif (useNumberId && props.field === \"id\" && props.action === \"create\") {\n\t\t\t\t\treturn db[props.model]!.length + 1;\n\t\t\t\t}\n\t\t\t\treturn props.data;\n\t\t\t},\n\t\t\ttransaction: async (cb) => {\n\t\t\t\tconst clone = structuredClone(db);\n\t\t\t\ttry {\n\t\t\t\t\tconst r = await cb(adapterCreator(lazyOptions!));\n\t\t\t\t\treturn r;\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Rollback changes\n\t\t\t\t\tObject.keys(db).forEach((key) => {\n\t\t\t\t\t\tdb[key] = clone[key]!;\n\t\t\t\t\t});\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\tadapter: ({ getFieldName, options, getModelName }) => {\n\t\t\tconst applySortToRecords = (\n\t\t\t\trecords: any[],\n\t\t\t\tsortBy: { field: string; direction: \"asc\" | \"desc\" } | undefined,\n\t\t\t\tmodel: string,\n\t\t\t) => {\n\t\t\t\tif (!sortBy) return records;\n\t\t\t\treturn records.sort((a: any, b: any) => {\n\t\t\t\t\tconst field = getFieldName({ model, field: sortBy.field });\n\t\t\t\t\tconst aValue = a[field];\n\t\t\t\t\tconst bValue = b[field];\n\n\t\t\t\t\tlet comparison = 0;\n\n\t\t\t\t\t// Handle null/undefined values\n\t\t\t\t\tif (aValue == null && bValue == null) {\n\t\t\t\t\t\tcomparison = 0;\n\t\t\t\t\t} else if (aValue == null) {\n\t\t\t\t\t\tcomparison = -1;\n\t\t\t\t\t} else if (bValue == null) {\n\t\t\t\t\t\tcomparison = 1;\n\t\t\t\t\t}\n\t\t\t\t\t// Handle string comparison\n\t\t\t\t\telse if (typeof aValue === \"string\" && typeof bValue === \"string\") {\n\t\t\t\t\t\tcomparison = aValue.localeCompare(bValue);\n\t\t\t\t\t}\n\t\t\t\t\t// Handle date comparison\n\t\t\t\t\telse if (aValue instanceof Date && bValue instanceof Date) {\n\t\t\t\t\t\tcomparison = aValue.getTime() - bValue.getTime();\n\t\t\t\t\t}\n\t\t\t\t\t// Handle numeric comparison\n\t\t\t\t\telse if (typeof aValue === \"number\" && typeof bValue === \"number\") {\n\t\t\t\t\t\tcomparison = aValue - bValue;\n\t\t\t\t\t}\n\t\t\t\t\t// Handle boolean comparison\n\t\t\t\t\telse if (typeof aValue === \"boolean\" && typeof bValue === \"boolean\") {\n\t\t\t\t\t\tcomparison = aValue === bValue ? 0 : aValue ? 1 : -1;\n\t\t\t\t\t}\n\t\t\t\t\t// Fallback to string comparison\n\t\t\t\t\telse {\n\t\t\t\t\t\tcomparison = String(aValue).localeCompare(String(bValue));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn sortBy.direction === \"asc\" ? comparison : -comparison;\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tfunction convertWhereClause(\n\t\t\t\twhere: CleanedWhere[],\n\t\t\t\tmodel: string,\n\t\t\t\tjoin?: JoinConfig,\n\t\t\t): any[] {\n\t\t\t\tconst execute = (where: CleanedWhere[], model: string) => {\n\t\t\t\t\tconst table = db[model];\n\t\t\t\t\tif (!table) {\n\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t`[MemoryAdapter] Model ${model} not found in the DB`,\n\t\t\t\t\t\t\tObject.keys(db),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthrow new Error(`Model ${model} not found`);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst evalClause = (record: any, clause: CleanedWhere): boolean => {\n\t\t\t\t\t\tconst { field, value, operator } = clause;\n\t\t\t\t\t\tswitch (operator) {\n\t\t\t\t\t\t\tcase \"in\":\n\t\t\t\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Value must be an array\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\t\treturn value.includes(record[field]);\n\t\t\t\t\t\t\tcase \"not_in\":\n\t\t\t\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Value must be an array\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\t\treturn !value.includes(record[field]);\n\t\t\t\t\t\t\tcase \"contains\":\n\t\t\t\t\t\t\t\treturn record[field].includes(value);\n\t\t\t\t\t\t\tcase \"starts_with\":\n\t\t\t\t\t\t\t\treturn record[field].startsWith(value);\n\t\t\t\t\t\t\tcase \"ends_with\":\n\t\t\t\t\t\t\t\treturn record[field].endsWith(value);\n\t\t\t\t\t\t\tcase \"ne\":\n\t\t\t\t\t\t\t\treturn record[field] !== value;\n\t\t\t\t\t\t\tcase \"gt\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] > value);\n\t\t\t\t\t\t\tcase \"gte\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] >= value);\n\t\t\t\t\t\t\tcase \"lt\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] < value);\n\t\t\t\t\t\t\tcase \"lte\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] <= value);\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn record[field] === value;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\treturn table.filter((record: any) => {\n\t\t\t\t\t\tif (!where.length || where.length === 0) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet result = evalClause(record, where[0]!);\n\t\t\t\t\t\tfor (const clause of where) {\n\t\t\t\t\t\t\tconst clauseResult = evalClause(record, clause);\n\n\t\t\t\t\t\t\tif (clause.connector === \"OR\") {\n\t\t\t\t\t\t\t\tresult = result || clauseResult;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult = result && clauseResult;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tif (!join) return execute(where, model);\n\n\t\t\t\tconst baseRecords = execute(where, model);\n\n\t\t\t\t// Group results by base model and nest joined data as arrays\n\t\t\t\tconst grouped = new Map<string, any>();\n\t\t\t\t// Track seen IDs per joined model for O(1) deduplication\n\t\t\t\tconst seenIds = new Map<string, Set<string>>();\n\n\t\t\t\tfor (const baseRecord of baseRecords) {\n\t\t\t\t\tconst baseId = String(baseRecord.id);\n\n\t\t\t\t\tif (!grouped.has(baseId)) {\n\t\t\t\t\t\tconst nested: Record<string, any> = { ...baseRecord };\n\n\t\t\t\t\t\t// Initialize joined data structures based on isUnique\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\t\tif (joinAttr.relation === \"one-to-one\") {\n\t\t\t\t\t\t\t\tnested[joinModelName] = null;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnested[joinModelName] = [];\n\t\t\t\t\t\t\t\tseenIds.set(`${baseId}-${joinModel}`, new Set());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgrouped.set(baseId, nested);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nestedEntry = grouped.get(baseId)!;\n\n\t\t\t\t\t// Add joined data\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\tconst joinTable = db[joinModelName];\n\t\t\t\t\t\tif (!joinTable) {\n\t\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\t`[MemoryAdapter] JoinOption model ${joinModelName} not found in the DB`,\n\t\t\t\t\t\t\t\tObject.keys(db),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthrow new Error(`JoinOption model ${joinModelName} not found`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst matchingRecords = joinTable.filter(\n\t\t\t\t\t\t\t(joinRecord: any) =>\n\t\t\t\t\t\t\t\tjoinRecord[joinAttr.on.to] === baseRecord[joinAttr.on.from],\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (joinAttr.relation === \"one-to-one\") {\n\t\t\t\t\t\t\t// For unique relationships, store a single object (or null)\n\t\t\t\t\t\t\tnestedEntry[joinModelName] = matchingRecords[0] || null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For non-unique relationships, store array with limit\n\t\t\t\t\t\t\tconst seenSet = seenIds.get(`${baseId}-${joinModel}`)!;\n\t\t\t\t\t\t\tconst limit = joinAttr.limit ?? 100;\n\t\t\t\t\t\t\tlet count = 0;\n\n\t\t\t\t\t\t\tfor (const matchingRecord of matchingRecords) {\n\t\t\t\t\t\t\t\tif (count >= limit) break;\n\t\t\t\t\t\t\t\tif (!seenSet.has(matchingRecord.id)) {\n\t\t\t\t\t\t\t\t\tnestedEntry[joinModelName].push(matchingRecord);\n\t\t\t\t\t\t\t\t\tseenSet.add(matchingRecord.id);\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn Array.from(grouped.values());\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tcreate: async ({ model, data }) => {\n\t\t\t\t\tconst useNumberId =\n\t\t\t\t\t\toptions.advanced?.database?.useNumberId ||\n\t\t\t\t\t\toptions.advanced?.database?.generateId === \"serial\";\n\t\t\t\t\tif (useNumberId) {\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tdata.id = db[getModelName(model)]!.length + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tdb[model] = [];\n\t\t\t\t\t}\n\t\t\t\t\tdb[model]!.push(data);\n\t\t\t\t\treturn data;\n\t\t\t\t},\n\t\t\t\tfindOne: async ({ model, where, join }) => {\n\t\t\t\t\tconst res = convertWhereClause(where, model, join);\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\t// When join is present, res is an array of nested objects\n\t\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\t\tif (!resArray.length) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Return the first nested object\n\t\t\t\t\t\treturn resArray[0];\n\t\t\t\t\t}\n\t\t\t\t\t// Without join, res is an array\n\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\tconst record = resArray[0] || null;\n\t\t\t\t\treturn record;\n\t\t\t\t},\n\t\t\t\tfindMany: async ({ model, where, sortBy, limit, offset, join }) => {\n\t\t\t\t\tconst res = convertWhereClause(where || [], model, join);\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\t// When join is present, res is an array of nested objects\n\t\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\t\tif (!resArray.length) {\n\t\t\t\t\t\t\treturn [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Apply sorting to nested objects\n\t\t\t\t\t\tapplySortToRecords(resArray, sortBy, model);\n\n\t\t\t\t\t\t// Apply offset and limit\n\t\t\t\t\t\tlet paginatedRecords = resArray;\n\t\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\t\tpaginatedRecords = paginatedRecords.slice(offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (limit !== undefined) {\n\t\t\t\t\t\t\tpaginatedRecords = paginatedRecords.slice(0, limit);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn paginatedRecords;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Without join - original logic\n\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\tlet table = applySortToRecords(resArray, sortBy, model);\n\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\ttable = table!.slice(offset);\n\t\t\t\t\t}\n\t\t\t\t\tif (limit !== undefined) {\n\t\t\t\t\t\ttable = table!.slice(0, limit);\n\t\t\t\t\t}\n\t\t\t\t\treturn table || [];\n\t\t\t\t},\n\t\t\t\tcount: async ({ model, where }) => {\n\t\t\t\t\tif (where) {\n\t\t\t\t\t\tconst filteredRecords = convertWhereClause(where, model);\n\t\t\t\t\t\treturn filteredRecords.length;\n\t\t\t\t\t}\n\t\t\t\t\treturn db[model]!.length;\n\t\t\t\t},\n\t\t\t\tupdate: async ({ model, where, update }) => {\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tres.forEach((record) => {\n\t\t\t\t\t\tObject.assign(record, update);\n\t\t\t\t\t});\n\t\t\t\t\treturn res[0] || null;\n\t\t\t\t},\n\t\t\t\tdelete: async ({ model, where }) => {\n\t\t\t\t\tconst table = db[model]!;\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tdb[model] = table.filter((record) => !res.includes(record));\n\t\t\t\t},\n\t\t\t\tdeleteMany: async ({ model, where }) => {\n\t\t\t\t\tconst table = db[model]!;\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tlet count = 0;\n\t\t\t\t\tdb[model] = table.filter((record) => {\n\t\t\t\t\t\tif (res.includes(record)) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn !res.includes(record);\n\t\t\t\t\t});\n\t\t\t\t\treturn count;\n\t\t\t\t},\n\t\t\t\tupdateMany({ model, where, update }) {\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tres.forEach((record) => {\n\t\t\t\t\t\tObject.assign(record, update);\n\t\t\t\t\t});\n\t\t\t\t\treturn res[0] || null;\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t});\n\treturn (options: BetterAuthOptions) => {\n\t\tlazyOptions = options;\n\t\treturn adapterCreator(options);\n\t};\n};\n"],"mappings":"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"}