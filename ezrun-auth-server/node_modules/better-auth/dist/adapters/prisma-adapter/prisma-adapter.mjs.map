{"version":3,"file":"prisma-adapter.mjs","names":["lazyOptions: BetterAuthOptions | null","prisma","result: Record<string, Record<string, any> | boolean>","schema","and","or","orClause","result: Record<string, any>","andClause","e: any","adapterOptions: AdapterFactoryOptions | null"],"sources":["../../../src/adapters/prisma-adapter/prisma-adapter.ts"],"sourcesContent":["import type { Awaitable, BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tAdapterFactoryCustomizeAdapterCreator,\n\tAdapterFactoryOptions,\n\tDBAdapter,\n\tDBAdapterDebugLogOption,\n\tJoinConfig,\n\tWhere,\n} from \"@better-auth/core/db/adapter\";\nimport { createAdapterFactory } from \"@better-auth/core/db/adapter\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\n\nexport interface PrismaConfig {\n\t/**\n\t * Database provider.\n\t */\n\tprovider:\n\t\t| \"sqlite\"\n\t\t| \"cockroachdb\"\n\t\t| \"mysql\"\n\t\t| \"postgresql\"\n\t\t| \"sqlserver\"\n\t\t| \"mongodb\";\n\n\t/**\n\t * Enable debug logs for the adapter\n\t *\n\t * @default false\n\t */\n\tdebugLogs?: DBAdapterDebugLogOption | undefined;\n\n\t/**\n\t * Use plural table names\n\t *\n\t * @default false\n\t */\n\tusePlural?: boolean | undefined;\n\n\t/**\n\t * Whether to execute multiple operations in a transaction.\n\t *\n\t * If the database doesn't support transactions,\n\t * set this to `false` and operations will be executed sequentially.\n\t * @default false\n\t */\n\ttransaction?: boolean | undefined;\n}\n\ninterface PrismaClient {}\n\ntype PrismaClientInternal = {\n\t$transaction: (\n\t\tcallback: (db: PrismaClient) => Awaitable<any>,\n\t) => Promise<any>;\n} & {\n\t[model: string]: {\n\t\tcreate: (data: any) => Promise<any>;\n\t\tfindFirst: (data: any) => Promise<any>;\n\t\tfindMany: (data: any) => Promise<any>;\n\t\tupdate: (data: any) => Promise<any>;\n\t\tupdateMany: (data: any) => Promise<any>;\n\t\tdelete: (data: any) => Promise<any>;\n\t\t[key: string]: any;\n\t};\n};\n\nexport const prismaAdapter = (prisma: PrismaClient, config: PrismaConfig) => {\n\tlet lazyOptions: BetterAuthOptions | null = null;\n\tconst createCustomAdapter =\n\t\t(prisma: PrismaClient): AdapterFactoryCustomizeAdapterCreator =>\n\t\t({\n\t\t\tgetFieldName,\n\t\t\tgetModelName,\n\t\t\tgetFieldAttributes,\n\t\t\tgetDefaultModelName,\n\t\t\tschema,\n\t\t}) => {\n\t\t\tconst db = prisma as PrismaClientInternal;\n\n\t\t\tconst convertSelect = (\n\t\t\t\tselect: string[] | undefined,\n\t\t\t\tmodel: string,\n\t\t\t\tjoin?: JoinConfig | undefined,\n\t\t\t) => {\n\t\t\t\tif (!select && !join) return undefined;\n\n\t\t\t\tconst result: Record<string, Record<string, any> | boolean> = {};\n\n\t\t\t\tif (select) {\n\t\t\t\t\tfor (const field of select) {\n\t\t\t\t\t\tresult[getFieldName({ model, field })] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (join) {\n\t\t\t\t\t// when joining that has a limit, we need to use Prisma's `select` syntax to append the limit to the field\n\t\t\t\t\t// because of such, it also means we need to select all base-model fields as well\n\t\t\t\t\t// should check if `select` is not provided, because then we should select all base-model fields\n\t\t\t\t\tif (!select) {\n\t\t\t\t\t\tconst fields = schema[getDefaultModelName(model)]?.fields || {};\n\t\t\t\t\t\tfields.id = { type: \"string\" }; // make sure there is at least an id field\n\t\t\t\t\t\tfor (const field of Object.keys(fields)) {\n\t\t\t\t\t\t\tresult[getFieldName({ model, field })] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\tconst key = getJoinKeyName(model, getModelName(joinModel), schema);\n\t\t\t\t\t\tif (joinAttr.relation === \"one-to-one\") {\n\t\t\t\t\t\t\tresult[key] = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult[key] = { take: joinAttr.limit };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Build the join key name based on whether the foreign field is unique or not.\n\t\t\t * If unique, use singular. Otherwise, pluralize (add 's').\n\t\t\t */\n\t\t\tconst getJoinKeyName = (\n\t\t\t\tbaseModel: string,\n\t\t\t\tjoinedModel: string,\n\t\t\t\tschema: any,\n\t\t\t): string => {\n\t\t\t\ttry {\n\t\t\t\t\tconst defaultBaseModelName = getDefaultModelName(baseModel);\n\t\t\t\t\tconst defaultJoinedModelName = getDefaultModelName(joinedModel);\n\t\t\t\t\tconst key = getModelName(joinedModel).toLowerCase();\n\n\t\t\t\t\t// First, check if the joined model has FKs to the base model (forward join)\n\t\t\t\t\tlet foreignKeys = Object.entries(\n\t\t\t\t\t\tschema[defaultJoinedModelName]?.fields || {},\n\t\t\t\t\t).filter(\n\t\t\t\t\t\t([_field, fieldAttributes]: any) =>\n\t\t\t\t\t\t\tfieldAttributes.references &&\n\t\t\t\t\t\t\tgetDefaultModelName(fieldAttributes.references.model) ===\n\t\t\t\t\t\t\t\tdefaultBaseModelName,\n\t\t\t\t\t);\n\n\t\t\t\t\tif (foreignKeys.length > 0) {\n\t\t\t\t\t\t// Forward join: joined model has FK to base model\n\t\t\t\t\t\t// This is typically a one-to-many relationship (plural)\n\t\t\t\t\t\t// Unless the FK is unique, then it's one-to-one (singular)\n\t\t\t\t\t\tconst [_foreignKey, foreignKeyAttributes] = foreignKeys[0] as any;\n\t\t\t\t\t\t// Only check if field is explicitly marked as unique\n\t\t\t\t\t\tconst isUnique = foreignKeyAttributes?.unique === true;\n\t\t\t\t\t\treturn isUnique || config.usePlural === true ? key : `${key}s`;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check backwards: does the base model have FKs to the joined model?\n\t\t\t\t\tforeignKeys = Object.entries(\n\t\t\t\t\t\tschema[defaultBaseModelName]?.fields || {},\n\t\t\t\t\t).filter(\n\t\t\t\t\t\t([_field, fieldAttributes]: any) =>\n\t\t\t\t\t\t\tfieldAttributes.references &&\n\t\t\t\t\t\t\tgetDefaultModelName(fieldAttributes.references.model) ===\n\t\t\t\t\t\t\t\tdefaultJoinedModelName,\n\t\t\t\t\t);\n\n\t\t\t\t\tif (foreignKeys.length > 0) {\n\t\t\t\t\t\treturn key;\n\t\t\t\t\t}\n\t\t\t\t} catch {\n\t\t\t\t\t// Fallback to pluralizing if we can't determine uniqueness\n\t\t\t\t}\n\t\t\t\treturn `${getModelName(joinedModel).toLowerCase()}s`;\n\t\t\t};\n\t\t\tfunction operatorToPrismaOperator(operator: string) {\n\t\t\t\tswitch (operator) {\n\t\t\t\t\tcase \"starts_with\":\n\t\t\t\t\t\treturn \"startsWith\";\n\t\t\t\t\tcase \"ends_with\":\n\t\t\t\t\t\treturn \"endsWith\";\n\t\t\t\t\tcase \"ne\":\n\t\t\t\t\t\treturn \"not\";\n\t\t\t\t\tcase \"not_in\":\n\t\t\t\t\t\treturn \"notIn\";\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn operator;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst convertWhereClause = ({\n\t\t\t\taction,\n\t\t\t\tmodel,\n\t\t\t\twhere,\n\t\t\t}: {\n\t\t\t\tmodel: string;\n\t\t\t\twhere?: Where[] | undefined;\n\t\t\t\taction:\n\t\t\t\t\t| \"create\"\n\t\t\t\t\t| \"update\"\n\t\t\t\t\t| \"delete\"\n\t\t\t\t\t| \"findOne\"\n\t\t\t\t\t| \"findMany\"\n\t\t\t\t\t| \"count\"\n\t\t\t\t\t| \"updateMany\"\n\t\t\t\t\t| \"deleteMany\";\n\t\t\t}) => {\n\t\t\t\tif (!where || !where.length) return {};\n\t\t\t\tconst buildSingleCondition = (w: Where) => {\n\t\t\t\t\tconst fieldName = getFieldName({ model, field: w.field });\n\t\t\t\t\t// Special handling for Prisma null semantics, for non-nullable fields this is a tautology. Skip condition.\n\t\t\t\t\tif (w.operator === \"ne\" && w.value === null) {\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\t(w.operator === \"in\" || w.operator === \"not_in\") &&\n\t\t\t\t\t\tArray.isArray(w.value)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst filtered = w.value.filter((v) => v != null);\n\t\t\t\t\t\tif (filtered.length === 0) {\n\t\t\t\t\t\t\tif (w.operator === \"in\") {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tAND: [\n\t\t\t\t\t\t\t\t\t\t{ [fieldName]: { equals: \"__never__\" } },\n\t\t\t\t\t\t\t\t\t\t{ [fieldName]: { not: \"__never__\" } },\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst prismaOp = operatorToPrismaOperator(w.operator);\n\t\t\t\t\t\treturn { [fieldName]: { [prismaOp]: filtered } };\n\t\t\t\t\t}\n\t\t\t\t\tif (w.operator === \"eq\" || !w.operator) {\n\t\t\t\t\t\treturn { [fieldName]: w.value };\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[fieldName]: {\n\t\t\t\t\t\t\t[operatorToPrismaOperator(w.operator)]: w.value,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Special handling for update actions: extract AND conditions with eq operator to root level\n\t\t\t\t// Prisma requires unique fields to be at root level, not nested in AND arrays\n\t\t\t\t// Only simple equality conditions can be at root level; complex operators must stay in AND array\n\t\t\t\tif (action === \"update\") {\n\t\t\t\t\tconst and = where.filter(\n\t\t\t\t\t\t(w) => w.connector === \"AND\" || !w.connector,\n\t\t\t\t\t);\n\t\t\t\t\tconst or = where.filter((w) => w.connector === \"OR\");\n\n\t\t\t\t\t// Separate AND conditions into simple eq (can extract) and complex (must stay in AND)\n\t\t\t\t\tconst andSimple = and.filter(\n\t\t\t\t\t\t(w) => w.operator === \"eq\" || !w.operator,\n\t\t\t\t\t);\n\t\t\t\t\tconst andComplex = and.filter(\n\t\t\t\t\t\t(w) => w.operator !== \"eq\" && w.operator !== undefined,\n\t\t\t\t\t);\n\n\t\t\t\t\tconst andSimpleClause = andSimple.map((w) => buildSingleCondition(w));\n\t\t\t\t\tconst andComplexClause = andComplex.map((w) =>\n\t\t\t\t\t\tbuildSingleCondition(w),\n\t\t\t\t\t);\n\t\t\t\t\tconst orClause = or.map((w) => buildSingleCondition(w));\n\n\t\t\t\t\t// Extract simple equality AND conditions to root level\n\t\t\t\t\tconst result: Record<string, any> = {};\n\t\t\t\t\tfor (const clause of andSimpleClause) {\n\t\t\t\t\t\tObject.assign(result, clause);\n\t\t\t\t\t}\n\t\t\t\t\t// Keep complex AND conditions in AND array\n\t\t\t\t\tif (andComplexClause.length > 0) {\n\t\t\t\t\t\tresult.AND = andComplexClause;\n\t\t\t\t\t}\n\t\t\t\t\tif (orClause.length > 0) {\n\t\t\t\t\t\tresult.OR = orClause;\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t// Special handling for delete actions: extract id to root level\n\t\t\t\tif (action === \"delete\") {\n\t\t\t\t\tconst idCondition = where.find((w) => w.field === \"id\");\n\t\t\t\t\tif (idCondition) {\n\t\t\t\t\t\tconst idFieldName = getFieldName({ model, field: \"id\" });\n\t\t\t\t\t\tconst idClause = buildSingleCondition(idCondition);\n\t\t\t\t\t\tconst remainingWhere = where.filter((w) => w.field !== \"id\");\n\n\t\t\t\t\t\tif (remainingWhere.length === 0) {\n\t\t\t\t\t\t\treturn idClause;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst and = remainingWhere.filter(\n\t\t\t\t\t\t\t(w) => w.connector === \"AND\" || !w.connector,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst or = remainingWhere.filter((w) => w.connector === \"OR\");\n\t\t\t\t\t\tconst andClause = and.map((w) => buildSingleCondition(w));\n\t\t\t\t\t\tconst orClause = or.map((w) => buildSingleCondition(w));\n\n\t\t\t\t\t\t// Extract id to root level, put other conditions in AND array\n\t\t\t\t\t\tconst result: Record<string, any> = {};\n\t\t\t\t\t\tif (idFieldName in idClause) {\n\t\t\t\t\t\t\tresult[idFieldName] = (idClause as Record<string, any>)[\n\t\t\t\t\t\t\t\tidFieldName\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Handle edge case where idClause might have special structure\n\t\t\t\t\t\t\tObject.assign(result, idClause);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (andClause.length > 0) {\n\t\t\t\t\t\t\tresult.AND = andClause;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (orClause.length > 0) {\n\t\t\t\t\t\t\tresult.OR = orClause;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (where.length === 1) {\n\t\t\t\t\tconst w = where[0]!;\n\t\t\t\t\tif (!w) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn buildSingleCondition(w);\n\t\t\t\t}\n\t\t\t\tconst and = where.filter((w) => w.connector === \"AND\" || !w.connector);\n\t\t\t\tconst or = where.filter((w) => w.connector === \"OR\");\n\t\t\t\tconst andClause = and.map((w) => buildSingleCondition(w));\n\t\t\t\tconst orClause = or.map((w) => buildSingleCondition(w));\n\n\t\t\t\treturn {\n\t\t\t\t\t...(andClause.length ? { AND: andClause } : {}),\n\t\t\t\t\t...(orClause.length ? { OR: orClause } : {}),\n\t\t\t\t};\n\t\t\t};\n\n\t\t\treturn {\n\t\t\t\tasync create({ model, data: values, select }) {\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst result = await db[model]!.create({\n\t\t\t\t\t\tdata: values,\n\t\t\t\t\t\tselect: convertSelect(select, model),\n\t\t\t\t\t});\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\t\t\t\tasync findOne({ model, where, select, join }) {\n\t\t\t\t\t// this is just \"JoinOption\" type because we disabled join transformation in adapter config\n\t\t\t\t\tconst whereClause = convertWhereClause({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t\taction: \"findOne\",\n\t\t\t\t\t});\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t// transform join keys to use Prisma expected field names\n\t\t\t\t\tconst map = new Map<string, string>();\n\t\t\t\t\tfor (const joinModel of Object.keys(join ?? {})) {\n\t\t\t\t\t\tconst key = getJoinKeyName(model, joinModel, schema);\n\t\t\t\t\t\tmap.set(key, getModelName(joinModel));\n\t\t\t\t\t}\n\n\t\t\t\t\tconst selects = convertSelect(select, model, join);\n\n\t\t\t\t\tconst result = await db[model]!.findFirst({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t\tselect: selects,\n\t\t\t\t\t});\n\n\t\t\t\t\t// transform the resulting `include` items to use better-auth expected field names\n\t\t\t\t\tif (join && result) {\n\t\t\t\t\t\tfor (const [includeKey, originalKey] of map.entries()) {\n\t\t\t\t\t\t\tif (includeKey === originalKey) continue;\n\t\t\t\t\t\t\tif (includeKey in result) {\n\t\t\t\t\t\t\t\tresult[originalKey] = result[includeKey];\n\t\t\t\t\t\t\t\tdelete result[includeKey];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\t\t\t\tasync findMany({ model, where, limit, offset, sortBy, join }) {\n\t\t\t\t\t// this is just \"JoinOption\" type because we disabled join transformation in adapter config\n\t\t\t\t\tconst whereClause = convertWhereClause({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t\taction: \"findMany\",\n\t\t\t\t\t});\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\t// transform join keys to use Prisma expected field names\n\t\t\t\t\tconst map = new Map<string, string>();\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tfor (const [joinModel, _value] of Object.entries(join)) {\n\t\t\t\t\t\t\tconst key = getJoinKeyName(model, joinModel, schema);\n\t\t\t\t\t\t\tmap.set(key, getModelName(joinModel));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst selects = convertSelect(undefined, model, join);\n\n\t\t\t\t\tconst result = await db[model]!.findMany({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t\ttake: limit || 100,\n\t\t\t\t\t\tskip: offset || 0,\n\t\t\t\t\t\t...(sortBy?.field\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\torderBy: {\n\t\t\t\t\t\t\t\t\t\t[getFieldName({ model, field: sortBy.field })]:\n\t\t\t\t\t\t\t\t\t\t\tsortBy.direction === \"desc\" ? \"desc\" : \"asc\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {}),\n\t\t\t\t\t\tselect: selects,\n\t\t\t\t\t});\n\n\t\t\t\t\t// transform the resulting join items to use better-auth expected field names\n\t\t\t\t\tif (join && Array.isArray(result)) {\n\t\t\t\t\t\tfor (const item of result) {\n\t\t\t\t\t\t\tfor (const [includeKey, originalKey] of map.entries()) {\n\t\t\t\t\t\t\t\tif (includeKey === originalKey) continue;\n\t\t\t\t\t\t\t\tif (includeKey in item) {\n\t\t\t\t\t\t\t\t\titem[originalKey] = item[includeKey];\n\t\t\t\t\t\t\t\t\tdelete item[includeKey];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\t\t\t\tasync count({ model, where }) {\n\t\t\t\t\tconst whereClause = convertWhereClause({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t\taction: \"count\",\n\t\t\t\t\t});\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn await db[model]!.count({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tasync update({ model, where, update }) {\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst whereClause = convertWhereClause({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t\taction: \"update\",\n\t\t\t\t\t});\n\n\t\t\t\t\treturn await db[model]!.update({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t\tdata: update,\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tasync updateMany({ model, where, update }) {\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst whereClause = convertWhereClause({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t\taction: \"updateMany\",\n\t\t\t\t\t});\n\t\t\t\t\tconst result = await db[model]!.updateMany({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t\tdata: update,\n\t\t\t\t\t});\n\t\t\t\t\treturn result ? (result.count as number) : 0;\n\t\t\t\t},\n\t\t\t\tasync delete({ model, where }) {\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tthrow new BetterAuthError(\n\t\t\t\t\t\t\t`Model ${model} does not exist in the database. If you haven't generated the Prisma client, you need to run 'npx prisma generate'`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tconst whereClause = convertWhereClause({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t\taction: \"delete\",\n\t\t\t\t\t});\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait db[model]!.delete({\n\t\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (e: any) {\n\t\t\t\t\t\t// If the record doesn't exist, we don't want to throw an error\n\t\t\t\t\t\tif (e?.meta?.cause === \"Record to delete does not exist.\") return;\n\t\t\t\t\t\t// otherwise if it's an unknown error, we want to just log it for debugging.\n\t\t\t\t\t\tconsole.log(e);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tasync deleteMany({ model, where }) {\n\t\t\t\t\tconst whereClause = convertWhereClause({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\twhere,\n\t\t\t\t\t\taction: \"deleteMany\",\n\t\t\t\t\t});\n\t\t\t\t\tconst result = await db[model]!.deleteMany({\n\t\t\t\t\t\twhere: whereClause,\n\t\t\t\t\t});\n\t\t\t\t\treturn result ? (result.count as number) : 0;\n\t\t\t\t},\n\t\t\t\toptions: config,\n\t\t\t};\n\t\t};\n\n\tlet adapterOptions: AdapterFactoryOptions | null = null;\n\tadapterOptions = {\n\t\tconfig: {\n\t\t\tadapterId: \"prisma\",\n\t\t\tadapterName: \"Prisma Adapter\",\n\t\t\tusePlural: config.usePlural ?? false,\n\t\t\tdebugLogs: config.debugLogs ?? false,\n\t\t\tsupportsUUIDs: config.provider === \"postgresql\" ? true : false,\n\t\t\tsupportsArrays:\n\t\t\t\tconfig.provider === \"postgresql\" || config.provider === \"mongodb\"\n\t\t\t\t\t? true\n\t\t\t\t\t: false,\n\t\t\ttransaction:\n\t\t\t\t(config.transaction ?? false)\n\t\t\t\t\t? (cb) =>\n\t\t\t\t\t\t\t(prisma as PrismaClientInternal).$transaction((tx) => {\n\t\t\t\t\t\t\t\tconst adapter = createAdapterFactory({\n\t\t\t\t\t\t\t\t\tconfig: adapterOptions!.config,\n\t\t\t\t\t\t\t\t\tadapter: createCustomAdapter(tx),\n\t\t\t\t\t\t\t\t})(lazyOptions!);\n\t\t\t\t\t\t\t\treturn cb(adapter);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t: false,\n\t\t},\n\t\tadapter: createCustomAdapter(prisma),\n\t};\n\n\tconst adapter = createAdapterFactory(adapterOptions);\n\treturn (options: BetterAuthOptions): DBAdapter<BetterAuthOptions> => {\n\t\tlazyOptions = options;\n\t\treturn adapter(options);\n\t};\n};\n"],"mappings":"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"}