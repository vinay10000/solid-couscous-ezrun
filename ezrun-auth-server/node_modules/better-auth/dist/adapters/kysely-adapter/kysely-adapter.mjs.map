{"version":3,"file":"kysely-adapter.mjs","names":["lazyOptions: BetterAuthOptions | null","allSelects: RawBuilder<unknown>[]","allSelectsStr: {\n\t\t\t\t\tjoinModel: string;\n\t\t\t\t\tjoinModelRef: string;\n\t\t\t\t\tfieldName: string;\n\t\t\t\t}[]","res: any","db","value: any","field: string | any","mainModelFields: Record<string, any>","joinedModelFields: Record<string, Record<string, any>>","entry: Record<string, any>","entry","query: any","eb","join","adapterOptions: AdapterFactoryOptions | null"],"sources":["../../../src/adapters/kysely-adapter/kysely-adapter.ts"],"sourcesContent":["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tAdapterFactoryCustomizeAdapterCreator,\n\tAdapterFactoryOptions,\n\tDBAdapter,\n\tDBAdapterDebugLogOption,\n\tJoinConfig,\n\tWhere,\n} from \"@better-auth/core/db/adapter\";\nimport { createAdapterFactory } from \"@better-auth/core/db/adapter\";\nimport type {\n\tInsertQueryBuilder,\n\tKysely,\n\tRawBuilder,\n\tUpdateQueryBuilder,\n} from \"kysely\";\nimport { sql } from \"kysely\";\nimport type { KyselyDatabaseType } from \"./types\";\n\ninterface KyselyAdapterConfig {\n\t/**\n\t * Database type.\n\t */\n\ttype?: KyselyDatabaseType | undefined;\n\t/**\n\t * Enable debug logs for the adapter\n\t *\n\t * @default false\n\t */\n\tdebugLogs?: DBAdapterDebugLogOption | undefined;\n\t/**\n\t * Use plural for table names.\n\t *\n\t * @default false\n\t */\n\tusePlural?: boolean | undefined;\n\t/**\n\t * Whether to execute multiple operations in a transaction.\n\t *\n\t * If the database doesn't support transactions,\n\t * set this to `false` and operations will be executed sequentially.\n\t * @default false\n\t */\n\ttransaction?: boolean | undefined;\n}\n\nexport const kyselyAdapter = (\n\tdb: Kysely<any>,\n\tconfig?: KyselyAdapterConfig | undefined,\n) => {\n\tlet lazyOptions: BetterAuthOptions | null = null;\n\tconst createCustomAdapter = (\n\t\tdb: Kysely<any>,\n\t): AdapterFactoryCustomizeAdapterCreator => {\n\t\treturn ({\n\t\t\tgetFieldName,\n\t\t\tschema,\n\t\t\tgetDefaultFieldName,\n\t\t\tgetDefaultModelName,\n\t\t\tgetFieldAttributes,\n\t\t\tgetModelName,\n\t\t}) => {\n\t\t\tconst selectAllJoins = (join: JoinConfig | undefined) => {\n\t\t\t\t// Use selectAll which will handle column naming appropriately\n\t\t\t\tconst allSelects: RawBuilder<unknown>[] = [];\n\t\t\t\tconst allSelectsStr: {\n\t\t\t\t\tjoinModel: string;\n\t\t\t\t\tjoinModelRef: string;\n\t\t\t\t\tfieldName: string;\n\t\t\t\t}[] = [];\n\t\t\t\tif (join) {\n\t\t\t\t\tfor (const [joinModel, _] of Object.entries(join)) {\n\t\t\t\t\t\tconst fields = schema[getDefaultModelName(joinModel)]?.fields;\n\t\t\t\t\t\tconst [_joinModelSchema, joinModelName] = joinModel.includes(\".\")\n\t\t\t\t\t\t\t? joinModel.split(\".\")\n\t\t\t\t\t\t\t: [undefined, joinModel];\n\n\t\t\t\t\t\tif (!fields) continue;\n\t\t\t\t\t\tfields.id = { type: \"string\" }; // make sure there is at least an id field\n\t\t\t\t\t\tfor (const [field, fieldAttr] of Object.entries(fields)) {\n\t\t\t\t\t\t\tallSelects.push(\n\t\t\t\t\t\t\t\tsql`${sql.ref(`join_${joinModelName}`)}.${sql.ref(fieldAttr.fieldName || field)} as ${sql.ref(`_joined_${joinModelName}_${fieldAttr.fieldName || field}`)}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tallSelectsStr.push({\n\t\t\t\t\t\t\t\tjoinModel: joinModel,\n\t\t\t\t\t\t\t\tjoinModelRef: joinModelName,\n\t\t\t\t\t\t\t\tfieldName: fieldAttr.fieldName || field,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn { allSelectsStr, allSelects };\n\t\t\t};\n\n\t\t\tconst withReturning = async (\n\t\t\t\tvalues: Record<string, any>,\n\t\t\t\tbuilder:\n\t\t\t\t\t| InsertQueryBuilder<any, any, any>\n\t\t\t\t\t| UpdateQueryBuilder<any, string, string, any>,\n\t\t\t\tmodel: string,\n\t\t\t\twhere: Where[],\n\t\t\t) => {\n\t\t\t\tlet res: any;\n\t\t\t\tif (config?.type === \"mysql\") {\n\t\t\t\t\t// This isn't good, but kysely doesn't support returning in mysql and it doesn't return the inserted id.\n\t\t\t\t\t// Change this if there is a better way.\n\t\t\t\t\tawait builder.execute();\n\t\t\t\t\tconst field = values.id\n\t\t\t\t\t\t? \"id\"\n\t\t\t\t\t\t: where.length > 0 && where[0]?.field\n\t\t\t\t\t\t\t? where[0].field\n\t\t\t\t\t\t\t: \"id\";\n\n\t\t\t\t\tif (!values.id && where.length === 0) {\n\t\t\t\t\t\tres = await db\n\t\t\t\t\t\t\t.selectFrom(model)\n\t\t\t\t\t\t\t.selectAll()\n\t\t\t\t\t\t\t.orderBy(getFieldName({ model, field }), \"desc\")\n\t\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t\t.executeTakeFirst();\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = values[field] || where[0]?.value;\n\t\t\t\t\tres = await db\n\t\t\t\t\t\t.selectFrom(model)\n\t\t\t\t\t\t.selectAll()\n\t\t\t\t\t\t.orderBy(getFieldName({ model, field }), \"desc\")\n\t\t\t\t\t\t.where(getFieldName({ model, field }), \"=\", value)\n\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t.executeTakeFirst();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tif (config?.type === \"mssql\") {\n\t\t\t\t\tres = await builder.outputAll(\"inserted\").executeTakeFirst();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tres = await builder.returningAll().executeTakeFirst();\n\t\t\t\treturn res;\n\t\t\t};\n\t\t\tfunction convertWhereClause(model: string, w?: Where[] | undefined) {\n\t\t\t\tif (!w)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tand: null,\n\t\t\t\t\t\tor: null,\n\t\t\t\t\t};\n\n\t\t\t\tconst conditions = {\n\t\t\t\t\tand: [] as any[],\n\t\t\t\t\tor: [] as any[],\n\t\t\t\t};\n\n\t\t\t\tw.forEach((condition) => {\n\t\t\t\t\tconst {\n\t\t\t\t\t\tfield: _field,\n\t\t\t\t\t\tvalue: _value,\n\t\t\t\t\t\toperator = \"=\",\n\t\t\t\t\t\tconnector = \"AND\",\n\t\t\t\t\t} = condition;\n\t\t\t\t\tconst value: any = _value;\n\t\t\t\t\tconst field: string | any = getFieldName({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tfield: _field,\n\t\t\t\t\t});\n\n\t\t\t\t\tconst expr = (eb: any) => {\n\t\t\t\t\t\tconst f = `${model}.${field}`;\n\t\t\t\t\t\tif (operator.toLowerCase() === \"in\") {\n\t\t\t\t\t\t\treturn eb(f, \"in\", Array.isArray(value) ? value : [value]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator.toLowerCase() === \"not_in\") {\n\t\t\t\t\t\t\treturn eb(f, \"not in\", Array.isArray(value) ? value : [value]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"contains\") {\n\t\t\t\t\t\t\treturn eb(f, \"like\", `%${value}%`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"starts_with\") {\n\t\t\t\t\t\t\treturn eb(f, \"like\", `${value}%`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"ends_with\") {\n\t\t\t\t\t\t\treturn eb(f, \"like\", `%${value}`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"eq\") {\n\t\t\t\t\t\t\treturn eb(f, \"=\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"ne\") {\n\t\t\t\t\t\t\treturn eb(f, \"<>\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"gt\") {\n\t\t\t\t\t\t\treturn eb(f, \">\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"gte\") {\n\t\t\t\t\t\t\treturn eb(f, \">=\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"lt\") {\n\t\t\t\t\t\t\treturn eb(f, \"<\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"lte\") {\n\t\t\t\t\t\t\treturn eb(f, \"<=\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn eb(f, operator, value);\n\t\t\t\t\t};\n\n\t\t\t\t\tif (connector === \"OR\") {\n\t\t\t\t\t\tconditions.or.push(expr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconditions.and.push(expr);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\tand: conditions.and.length ? conditions.and : null,\n\t\t\t\t\tor: conditions.or.length ? conditions.or : null,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfunction processJoinedResults(\n\t\t\t\trows: any[],\n\t\t\t\tjoinConfig: JoinConfig | undefined,\n\t\t\t\tallSelectsStr: {\n\t\t\t\t\tjoinModel: string;\n\t\t\t\t\tjoinModelRef: string;\n\t\t\t\t\tfieldName: string;\n\t\t\t\t}[],\n\t\t\t) {\n\t\t\t\tif (!joinConfig || !rows.length) {\n\t\t\t\t\treturn rows;\n\t\t\t\t}\n\n\t\t\t\t// Group rows by main model ID\n\t\t\t\tconst groupedByMainId = new Map<string, any>();\n\n\t\t\t\tfor (const currentRow of rows) {\n\t\t\t\t\t// Separate main model columns from joined columns\n\t\t\t\t\tconst mainModelFields: Record<string, any> = {};\n\t\t\t\t\tconst joinedModelFields: Record<string, Record<string, any>> = {};\n\n\t\t\t\t\t// Initialize joined model fields map\n\t\t\t\t\tfor (const [joinModel] of Object.entries(joinConfig)) {\n\t\t\t\t\t\tjoinedModelFields[getModelName(joinModel)] = {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Distribute all columns - collect complete objects per model\n\t\t\t\t\tfor (const [key, value] of Object.entries(currentRow)) {\n\t\t\t\t\t\tconst keyStr = String(key);\n\t\t\t\t\t\tlet assigned = false;\n\n\t\t\t\t\t\t// Check if this is a joined column\n\t\t\t\t\t\tfor (const {\n\t\t\t\t\t\t\tjoinModel,\n\t\t\t\t\t\t\tfieldName,\n\t\t\t\t\t\t\tjoinModelRef,\n\t\t\t\t\t\t} of allSelectsStr) {\n\t\t\t\t\t\t\tif (keyStr === `_joined_${joinModelRef}_${fieldName}`) {\n\t\t\t\t\t\t\t\tjoinedModelFields[getModelName(joinModel)]![\n\t\t\t\t\t\t\t\t\tgetFieldName({\n\t\t\t\t\t\t\t\t\t\tmodel: joinModel,\n\t\t\t\t\t\t\t\t\t\tfield: fieldName,\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t] = value;\n\t\t\t\t\t\t\t\tassigned = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!assigned) {\n\t\t\t\t\t\t\tmainModelFields[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst mainId = mainModelFields.id;\n\t\t\t\t\tif (!mainId) continue;\n\n\t\t\t\t\t// Initialize or get existing entry for this main model\n\t\t\t\t\tif (!groupedByMainId.has(mainId)) {\n\t\t\t\t\t\tconst entry: Record<string, any> = { ...mainModelFields };\n\n\t\t\t\t\t\t// Initialize joined models based on uniqueness\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(joinConfig)) {\n\t\t\t\t\t\t\tentry[getModelName(joinModel)] =\n\t\t\t\t\t\t\t\tjoinAttr.relation === \"one-to-one\" ? null : [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgroupedByMainId.set(mainId, entry);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst entry = groupedByMainId.get(mainId)!;\n\n\t\t\t\t\t// Add joined records to the entry\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(joinConfig)) {\n\t\t\t\t\t\tconst isUnique = joinAttr.relation === \"one-to-one\";\n\t\t\t\t\t\tconst limit = joinAttr.limit ?? 100;\n\n\t\t\t\t\t\tconst joinedObj = joinedModelFields[getModelName(joinModel)];\n\n\t\t\t\t\t\tconst hasData =\n\t\t\t\t\t\t\tjoinedObj &&\n\t\t\t\t\t\t\tObject.keys(joinedObj).length > 0 &&\n\t\t\t\t\t\t\tObject.values(joinedObj).some(\n\t\t\t\t\t\t\t\t(value) => value !== null && value !== undefined,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (isUnique) {\n\t\t\t\t\t\t\tentry[getModelName(joinModel)] = hasData ? joinedObj : null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For arrays, append if not already there (deduplicate by id) and respect limit\n\t\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\t\tif (Array.isArray(entry[joinModelName]) && hasData) {\n\t\t\t\t\t\t\t\t// Check if we've reached the limit before processing\n\t\t\t\t\t\t\t\tif (entry[joinModelName].length >= limit) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Get the id field name using getFieldName to ensure correct transformation\n\t\t\t\t\t\t\t\tconst idFieldName = getFieldName({\n\t\t\t\t\t\t\t\t\tmodel: joinModel,\n\t\t\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst joinedId = joinedObj[idFieldName];\n\n\t\t\t\t\t\t\t\t// Only deduplicate if we have an id field\n\t\t\t\t\t\t\t\tif (joinedId) {\n\t\t\t\t\t\t\t\t\tconst exists = entry[joinModelName].some(\n\t\t\t\t\t\t\t\t\t\t(item: any) => item[idFieldName] === joinedId,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (!exists && entry[joinModelName].length < limit) {\n\t\t\t\t\t\t\t\t\t\tentry[joinModelName].push(joinedObj);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// If no id field, still add the object if it has data and limit not reached\n\t\t\t\t\t\t\t\t\tif (entry[joinModelName].length < limit) {\n\t\t\t\t\t\t\t\t\t\tentry[joinModelName].push(joinedObj);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst result = Array.from(groupedByMainId.values());\n\n\t\t\t\t// Apply final limit to non-unique join arrays as a safety measure\n\t\t\t\tfor (const entry of result) {\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(joinConfig)) {\n\t\t\t\t\t\tif (joinAttr.relation !== \"one-to-one\") {\n\t\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\t\tif (Array.isArray(entry[joinModelName])) {\n\t\t\t\t\t\t\t\tconst limit = joinAttr.limit ?? 100;\n\t\t\t\t\t\t\t\tif (entry[joinModelName].length > limit) {\n\t\t\t\t\t\t\t\t\tentry[joinModelName] = entry[joinModelName].slice(0, limit);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tasync create({ data, model }) {\n\t\t\t\t\tconst builder = db.insertInto(model).values(data);\n\t\t\t\t\tconst returned = await withReturning(data, builder, model, []);\n\t\t\t\t\treturn returned;\n\t\t\t\t},\n\t\t\t\tasync findOne({ model, where, select, join }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query: any = db\n\t\t\t\t\t\t.selectFrom((eb) => {\n\t\t\t\t\t\t\tlet b = eb.selectFrom(model);\n\t\t\t\t\t\t\tif (and) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.and(and.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (or) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.or(or.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn b.selectAll().as(\"primary\");\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.selectAll(\"primary\");\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\t\tconst [_joinModelSchema, joinModelName] = joinModel.includes(\".\")\n\t\t\t\t\t\t\t\t? joinModel.split(\".\")\n\t\t\t\t\t\t\t\t: [undefined, joinModel];\n\n\t\t\t\t\t\t\tquery = query.leftJoin(\n\t\t\t\t\t\t\t\t`${joinModel} as join_${joinModelName}`,\n\t\t\t\t\t\t\t\t(join: any) =>\n\t\t\t\t\t\t\t\t\tjoin.onRef(\n\t\t\t\t\t\t\t\t\t\t`join_${joinModelName}.${joinAttr.on.to}`,\n\t\t\t\t\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\t\t\t\t`primary.${joinAttr.on.from}`,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { allSelectsStr, allSelects } = selectAllJoins(join);\n\t\t\t\t\tquery = query.select(allSelects);\n\n\t\t\t\t\tconst res = await query.execute();\n\t\t\t\t\tif (!res || !Array.isArray(res) || res.length === 0) return null;\n\n\t\t\t\t\t// Get the first row from the result array\n\t\t\t\t\tconst row = res[0];\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tconst processedRows = processJoinedResults(\n\t\t\t\t\t\t\tres,\n\t\t\t\t\t\t\tjoin,\n\t\t\t\t\t\t\tallSelectsStr,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn processedRows[0] as any;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn row as any;\n\t\t\t\t},\n\t\t\t\tasync findMany({ model, where, limit, offset, sortBy, join }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query: any = db\n\t\t\t\t\t\t.selectFrom((eb) => {\n\t\t\t\t\t\t\tlet b = eb.selectFrom(model);\n\n\t\t\t\t\t\t\tif (config?.type === \"mssql\") {\n\t\t\t\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\t\t\t\tif (!sortBy) {\n\t\t\t\t\t\t\t\t\t\tb = b.orderBy(getFieldName({ model, field: \"id\" }));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tb = b.offset(offset).fetch(limit || 100);\n\t\t\t\t\t\t\t\t} else if (limit !== undefined) {\n\t\t\t\t\t\t\t\t\tb = b.top(limit);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (limit !== undefined) {\n\t\t\t\t\t\t\t\t\tb = b.limit(limit);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\t\t\t\tb = b.offset(offset);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (sortBy?.field) {\n\t\t\t\t\t\t\t\tb = b.orderBy(\n\t\t\t\t\t\t\t\t\t`${getFieldName({ model, field: sortBy.field })}`,\n\t\t\t\t\t\t\t\t\tsortBy.direction,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (and) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.and(and.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (or) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.or(or.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn b.selectAll().as(\"primary\");\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.selectAll(\"primary\");\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\t\t// it's possible users provide a schema name in the model name (`<schema>.<model>`)\n\t\t\t\t\t\t\tconst [_joinModelSchema, joinModelName] = joinModel.includes(\".\")\n\t\t\t\t\t\t\t\t? joinModel.split(\".\")\n\t\t\t\t\t\t\t\t: [undefined, joinModel];\n\n\t\t\t\t\t\t\tquery = query.leftJoin(\n\t\t\t\t\t\t\t\t`${joinModel} as join_${joinModelName}`,\n\t\t\t\t\t\t\t\t(join: any) =>\n\t\t\t\t\t\t\t\t\tjoin.onRef(\n\t\t\t\t\t\t\t\t\t\t`join_${joinModelName}.${joinAttr.on.to}`,\n\t\t\t\t\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\t\t\t\t`primary.${joinAttr.on.from}`,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { allSelectsStr, allSelects } = selectAllJoins(join);\n\n\t\t\t\t\tquery = query.select(allSelects);\n\n\t\t\t\t\tif (sortBy?.field) {\n\t\t\t\t\t\tquery = query.orderBy(\n\t\t\t\t\t\t\t`${getFieldName({ model, field: sortBy.field })}`,\n\t\t\t\t\t\t\tsortBy.direction,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst res = await query.execute();\n\n\t\t\t\t\tif (!res) return [];\n\t\t\t\t\tif (join) return processJoinedResults(res, join, allSelectsStr);\n\t\t\t\t\treturn res;\n\t\t\t\t},\n\t\t\t\tasync update({ model, where, update: values }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\n\t\t\t\t\tlet query = db.updateTable(model).set(values as any);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\treturn await withReturning(values as any, query, model, where);\n\t\t\t\t},\n\t\t\t\tasync updateMany({ model, where, update: values }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db.updateTable(model).set(values as any);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tconst res = (await query.executeTakeFirst()).numUpdatedRows;\n\t\t\t\t\treturn res > Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t? Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t: Number(res);\n\t\t\t\t},\n\t\t\t\tasync count({ model, where }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db\n\t\t\t\t\t\t.selectFrom(model)\n\t\t\t\t\t\t// a temporal solution for counting other than \"*\" - see more - https://www.sqlite.org/quirks.html#double_quoted_string_literals_are_accepted\n\t\t\t\t\t\t.select(db.fn.count(\"id\").as(\"count\"));\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tconst res = await query.execute();\n\t\t\t\t\tif (typeof res[0]!.count === \"number\") {\n\t\t\t\t\t\treturn res[0]!.count;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof res[0]!.count === \"bigint\") {\n\t\t\t\t\t\treturn Number(res[0]!.count);\n\t\t\t\t\t}\n\t\t\t\t\treturn parseInt(res[0]!.count);\n\t\t\t\t},\n\t\t\t\tasync delete({ model, where }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db.deleteFrom(model);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tawait query.execute();\n\t\t\t\t},\n\t\t\t\tasync deleteMany({ model, where }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db.deleteFrom(model);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tconst res = (await query.executeTakeFirst()).numDeletedRows;\n\t\t\t\t\treturn res > Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t? Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t: Number(res);\n\t\t\t\t},\n\t\t\t\toptions: config,\n\t\t\t};\n\t\t};\n\t};\n\tlet adapterOptions: AdapterFactoryOptions | null = null;\n\tadapterOptions = {\n\t\tconfig: {\n\t\t\tadapterId: \"kysely\",\n\t\t\tadapterName: \"Kysely Adapter\",\n\t\t\tusePlural: config?.usePlural,\n\t\t\tdebugLogs: config?.debugLogs,\n\t\t\tsupportsBooleans:\n\t\t\t\tconfig?.type === \"sqlite\" ||\n\t\t\t\tconfig?.type === \"mssql\" ||\n\t\t\t\tconfig?.type === \"mysql\" ||\n\t\t\t\t!config?.type\n\t\t\t\t\t? false\n\t\t\t\t\t: true,\n\t\t\tsupportsDates:\n\t\t\t\tconfig?.type === \"sqlite\" || config?.type === \"mssql\" || !config?.type\n\t\t\t\t\t? false\n\t\t\t\t\t: true,\n\t\t\tsupportsJSON:\n\t\t\t\tconfig?.type === \"postgres\"\n\t\t\t\t\t? true // even if there is JSON support, only pg supports passing direct json, all others must stringify\n\t\t\t\t\t: false,\n\t\t\tsupportsArrays: false, // Even if field supports JSON, we must pass stringified arrays to the database.\n\t\t\tsupportsUUIDs: config?.type === \"postgres\" ? true : false,\n\t\t\ttransaction: config?.transaction\n\t\t\t\t? (cb) =>\n\t\t\t\t\t\tdb.transaction().execute((trx) => {\n\t\t\t\t\t\t\tconst adapter = createAdapterFactory({\n\t\t\t\t\t\t\t\tconfig: adapterOptions!.config,\n\t\t\t\t\t\t\t\tadapter: createCustomAdapter(trx),\n\t\t\t\t\t\t\t})(lazyOptions!);\n\t\t\t\t\t\t\treturn cb(adapter);\n\t\t\t\t\t\t})\n\t\t\t\t: false,\n\t\t},\n\t\tadapter: createCustomAdapter(db),\n\t};\n\n\tconst adapter = createAdapterFactory(adapterOptions);\n\n\treturn (options: BetterAuthOptions): DBAdapter<BetterAuthOptions> => {\n\t\tlazyOptions = options;\n\t\treturn adapter(options);\n\t};\n};\n"],"mappings":"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"}