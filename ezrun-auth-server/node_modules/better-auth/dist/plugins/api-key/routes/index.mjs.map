{"version":3,"file":"index.mjs","names":["lastChecked: Date | null"],"sources":["../../../../src/plugins/api-key/routes/index.ts"],"sourcesContent":["import type { AuthContext, Awaitable } from \"@better-auth/core\";\nimport { API_KEY_TABLE_NAME } from \"..\";\nimport type { apiKeySchema } from \"../schema\";\nimport type { ApiKey, ApiKeyOptions } from \"../types\";\nimport { createApiKey } from \"./create-api-key\";\nimport { deleteAllExpiredApiKeysEndpoint } from \"./delete-all-expired-api-keys\";\nimport { deleteApiKey } from \"./delete-api-key\";\nimport { getApiKey } from \"./get-api-key\";\nimport { listApiKeys } from \"./list-api-keys\";\nimport { updateApiKey } from \"./update-api-key\";\nimport { verifyApiKey } from \"./verify-api-key\";\n\nexport type PredefinedApiKeyOptions = ApiKeyOptions &\n\tRequired<\n\t\tPick<\n\t\t\tApiKeyOptions,\n\t\t\t| \"apiKeyHeaders\"\n\t\t\t| \"defaultKeyLength\"\n\t\t\t| \"keyExpiration\"\n\t\t\t| \"rateLimit\"\n\t\t\t| \"maximumPrefixLength\"\n\t\t\t| \"minimumPrefixLength\"\n\t\t\t| \"maximumNameLength\"\n\t\t\t| \"disableKeyHashing\"\n\t\t\t| \"minimumNameLength\"\n\t\t\t| \"requireName\"\n\t\t\t| \"enableMetadata\"\n\t\t\t| \"enableSessionForAPIKeys\"\n\t\t\t| \"startingCharactersConfig\"\n\t\t\t| \"storage\"\n\t\t\t| \"fallbackToDatabase\"\n\t\t\t| \"deferUpdates\"\n\t\t>\n\t> & {\n\t\tkeyExpiration: Required<ApiKeyOptions[\"keyExpiration\"]>;\n\t\tstartingCharactersConfig: Required<\n\t\t\tApiKeyOptions[\"startingCharactersConfig\"]\n\t\t>;\n\t};\n\nlet lastChecked: Date | null = null;\n\nexport async function deleteAllExpiredApiKeys(\n\tctx: AuthContext,\n\tbyPassLastCheckTime = false,\n): Promise<void> {\n\tif (lastChecked && !byPassLastCheckTime) {\n\t\tconst now = new Date();\n\t\tconst diff = now.getTime() - lastChecked.getTime();\n\t\tif (diff < 10000) {\n\t\t\treturn;\n\t\t}\n\t}\n\tlastChecked = new Date();\n\tawait ctx.adapter\n\t\t.deleteMany({\n\t\t\tmodel: API_KEY_TABLE_NAME,\n\t\t\twhere: [\n\t\t\t\t{\n\t\t\t\t\tfield: \"expiresAt\" satisfies keyof ApiKey,\n\t\t\t\t\toperator: \"lt\",\n\t\t\t\t\tvalue: new Date(),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfield: \"expiresAt\",\n\t\t\t\t\toperator: \"ne\",\n\t\t\t\t\tvalue: null,\n\t\t\t\t},\n\t\t\t],\n\t\t})\n\t\t.catch((error) => {\n\t\t\tctx.logger.error(`Failed to delete expired API keys:`, error);\n\t\t});\n}\n\nexport function createApiKeyRoutes({\n\tkeyGenerator,\n\topts,\n\tschema,\n}: {\n\tkeyGenerator: (options: {\n\t\tlength: number;\n\t\tprefix: string | undefined;\n\t}) => Awaitable<string>;\n\topts: PredefinedApiKeyOptions;\n\tschema: ReturnType<typeof apiKeySchema>;\n}) {\n\treturn {\n\t\tcreateApiKey: createApiKey({\n\t\t\tkeyGenerator,\n\t\t\topts,\n\t\t\tschema,\n\t\t\tdeleteAllExpiredApiKeys,\n\t\t}),\n\t\tverifyApiKey: verifyApiKey({ opts, schema, deleteAllExpiredApiKeys }),\n\t\tgetApiKey: getApiKey({ opts, schema, deleteAllExpiredApiKeys }),\n\t\tupdateApiKey: updateApiKey({ opts, schema, deleteAllExpiredApiKeys }),\n\t\tdeleteApiKey: deleteApiKey({ opts, schema, deleteAllExpiredApiKeys }),\n\t\tlistApiKeys: listApiKeys({ opts, schema, deleteAllExpiredApiKeys }),\n\t\tdeleteAllExpiredApiKeys: deleteAllExpiredApiKeysEndpoint({\n\t\t\tdeleteAllExpiredApiKeys,\n\t\t}),\n\t};\n}\n"],"mappings":";;;;;;;;;;AAwCA,IAAIA,cAA2B;AAE/B,eAAsB,wBACrB,KACA,sBAAsB,OACN;AAChB,KAAI,eAAe,CAAC,qBAGnB;uBAFY,IAAI,MAAM,EACL,SAAS,GAAG,YAAY,SAAS,GACvC,IACV;;AAGF,+BAAc,IAAI,MAAM;AACxB,OAAM,IAAI,QACR,WAAW;EACX,OAAO;EACP,OAAO,CACN;GACC,OAAO;GACP,UAAU;GACV,uBAAO,IAAI,MAAM;GACjB,EACD;GACC,OAAO;GACP,UAAU;GACV,OAAO;GACP,CACD;EACD,CAAC,CACD,OAAO,UAAU;AACjB,MAAI,OAAO,MAAM,sCAAsC,MAAM;GAC5D;;AAGJ,SAAgB,mBAAmB,EAClC,cACA,MACA,UAQE;AACF,QAAO;EACN,cAAc,aAAa;GAC1B;GACA;GACA;GACA;GACA,CAAC;EACF,cAAc,aAAa;GAAE;GAAM;GAAQ;GAAyB,CAAC;EACrE,WAAW,UAAU;GAAE;GAAM;GAAQ;GAAyB,CAAC;EAC/D,cAAc,aAAa;GAAE;GAAM;GAAQ;GAAyB,CAAC;EACrE,cAAc,aAAa;GAAE;GAAM;GAAQ;GAAyB,CAAC;EACrE,aAAa,YAAY;GAAE;GAAM;GAAQ;GAAyB,CAAC;EACnE,yBAAyB,gCAAgC,EACxD,yBACA,CAAC;EACF"}